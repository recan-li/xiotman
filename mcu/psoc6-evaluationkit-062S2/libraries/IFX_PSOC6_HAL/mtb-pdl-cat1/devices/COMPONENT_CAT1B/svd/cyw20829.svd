<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>cyw20829</name>
  <series>CYW20829</series>
  <version>1.0</version>
  <description>CYW20829</description>
  <licenseText>(c) (2016-2021), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of peripheral group root undivided (clk_group_root[i]) clock cycles. If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB5 bus error and a timeout status is set. '0x0000'-'0xfffe': Number of peripheral group clock cycles. '0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated, and a interrupt will never be generated.
Note that TIMEOUT_CTL.TIMEOUT[15:0] in clk_pclk0_root (clk_hf0) is used directly in peripheral group clock domain clk_group_root[i], even if clk_group_root[i] is async to clk_pclk0_root. This is on the assumption that this register is programmed once by SW, remain constant. Following SW programming restrictions apply to TIMEOUT_CTL.TIMEOUT[15:0]. SW should make sure that no other AHB transactions are initiated through PERI before programming this register. SW should make sure that write to TIMEOUT_CTL.TIMEOUT[15:0] is completed by doing a readback.
Note that peripheral group-0 slaves are excluded from timeout (Refer Timeout section in mxsperi.1 BROS for more details).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWRST_DISABLE</name>
              <description>This field provides control for HW to reset the slave that is causing the timeout to occur. 
1 - no HW reset during timeout.
0 - HW resets the corresponding slave during timeout. 
This ensures the AHB bus not to be hung after a timeout has occurred. HW asserts the reset only when INTR_AHB_ERROR.TIMEOUT_VIO[i]=1. SW needs to clear the INTR_AHB_ERROR.TIMEOUT_VIO[i]=0 before re-initialize the corresponding slave. ('i' -represents the peripheral group number)
Note, SW needs to take care of the implication when clearing this bit when a HW reset has occurred as clearing this bit will cause HW reset de-assert. 
Note that peripheral group-0 slaves are excluded from timeout (Refer Timeout section in mxsperi.1 BROS for more details).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>AHB_ERROR_STATUS1[%s]</name>
          <description>AHB error status1</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>This field indicates the AHB transaction address[31:0] that the AHB error response is detected. This field is valid when INTR_AHB_ERROR.AHB_ERROR_VIO[i] is set for respective peripheral group (i-represent group number). Note that quantity of this register is '16', each register is dedicated to peripheral group-i starting from group-0;</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>AHB_ERROR_STATUS2[%s]</name>
          <description>AHB error status2</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>W</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>N/A</description>
              <bitRange>[23:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPE</name>
              <description>N/A</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>AHB_ERROR_STATUS3[%s]</name>
          <description>AHB error status3</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SLAVE_NO</name>
              <description>Indicate slave number in respective peripheral group for which Timeout is detected.
This field is valid when INTR_AHB_ERROR.TIMEOUT[i] is set for respective peripheral group (i-represents peripheral group). 
Note that quantity of this register is '16', each register is dedicated to peripheral group-i starting from group-1;</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_AHB_ERROR</name>
          <description>Interrupt AHB error</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFEFFFF</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR_VIO</name>
              <description>HW sets respective bit in this field to '1', when AHB error is detected on respective peripheral group. This is 16-bit interrupt register field.
Bit-0 indicates AHB error response is detected in peripheral group-0, 
Bit-1 indicates AHB error response is detected in peripheral group-1, 
             .. 
Bit-15 indicates AHB error response is detected in peripheral group-15.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_VIO</name>
              <description>HW sets respective bit in this field to '1', when AHB timeout  is detected on respective peripheral group. This is 15-bit interrupt register field.
Bit-17 indicates AHB timeout is detected in peripheral group-1, 
Bit-18 indicates AHB timeout is detected in peripheral group-2, 
             .. 
Bit-31 indicates AHB timeout is detected in peripheral group-15.</description>
              <bitRange>[31:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_AHB_ERROR_SET</name>
          <description>Interrupt AHB error set</description>
          <addressOffset>0x10C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFEFFFF</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR_VIO</name>
              <description>Write this field with '1' to set corresponding INTR_AHB_ERROR field (a write of '0' has no effect).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_VIO</name>
              <description>Write this field with '1' to set corresponding INTR_AHB_ERROR field (a write of '0' has no effect).</description>
              <bitRange>[31:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_AHB_ERROR_MASK</name>
          <description>Interrupt AHB error mask</description>
          <addressOffset>0x10C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFEFFFF</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR_VIO</name>
              <description>Mask for corresponding field in INTR_AHB_ERROR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_VIO</name>
              <description>Mask for corresponding field in INTR_AHB_ERROR register.</description>
              <bitRange>[31:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_AHB_ERROR_MASKED</name>
          <description>Interrupt AHB error masked</description>
          <addressOffset>0x10CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFEFFFF</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR_VIO</name>
              <description>Logical AND of corresponding INTR_AHB_ERROR and INTR_AHB_ERROR_MASK fields.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT_VIO</name>
              <description>Logical AND of corresponding INTR_AHB_ERROR and INTR_AHB_ERROR_MASK fields.</description>
              <bitRange>[31:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFRA_CLK_FORCE</name>
          <description>Infrastructure clock force enable</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Infrastructure clock force enable.
0: Disabled
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>64</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[1/2/3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Slave Enable. Each bit indicates whether the respective slave is enabled. If the slave is disabled, its clock is gated off (constant '0').

Note: For peripheral group 0 slave 0,1, and 2 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.
The peripheral IP that drives the Q-Channel back to Clock Controllers need to ensure that it has clock (usually driven by Clk_hf1~N that is only available after CPU configures their roots in the SRSS) to provide back the Q-Channel handshake, if not the deadlock situation will procure. To avoid deadlock mentioned above, all IPs in all groups other than group-0 are disabled  (SL_CTL.ENABLED is set to '0') by default after POR (cold boot) (i.e. PERI HW hardcodes local parameter SL_CTL_DEFAULT to 32'hFFFFFFFF for group-0 and to 32'h00000000 for other groups (group-1 to group-15)).  Once CPU is up and running &amp; Clk_hf1~N configured, CPU can enable them.
The SL_CTL.ENABLED are retained during DEEPSLEEP to avoid enabling configuration after wakeup.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL2</name>
            <description>Slave control2</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RST</name>
                <description>Slave reset. Each bit indicates whether the respective slave is enabled. If the slave is under reset, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 slave 0,1, and 2 (the peripheral interconnect MMIO registers), this field is a constant '0' (SW: R): the slave can NOT be in reset.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL3</name>
            <description>Slave control3</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SS_POWERSTATE</name>
                <description>Slave status to represent subsystem (SS) IP current power status. Each bit represents the respective IP power state (Note that separate mxsperi peripheral group should be defined for type4 peripheral, should not be mixed with type1/2/3 and same peripheral group can have multiple type4 peripherals)
0 - indiacates IP is in OFF state.
1 - indicates IP is in ON state.
This register exists only for peripheral group with type4 peripherals (has its own PPU, P/Q-Channel consolidation and clock gating).
This is readonly register connecting to PERI input signal coming from the respective SS IP.
Since this register is passthorugh of status signal from peripheral the default value defined is w.r.t. respective IP reset.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>10</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>5</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PPC</name>
      <description>Peripheral Protection Controller</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>PPC Control Registers</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>RESP_CFG</name>
              <description>Response Configuration. This field configures the security violation response.
0 - Read-Zero Write Ignore (RZWI)
1 - Bus Error</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS1</name>
          <description>Status1 Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07F3FF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>Index to indicate which peripheral region has first violated security access when INTR_PPC.SECURE_VIO=1. This field is only valid when INTR_PPC.SECURE_VIO=1.
Note that when STATUS1.TYPE=AHB_ERROR (3'd5), this field is not valid.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Indicates the master interface transaction PC value when violation is detected.
This field is only valid when INTR_PPC.SECURE_VIO=1.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPE</name>
              <description>N/A</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>Indicates the Master ID of violating transfer.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS2</name>
          <description>Status2 Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Indicates the address of PPC violating transfer. STATUS2.ADDR status register is addition to PPC STATUS1 register. And all rules applicable for STATUS1 is applies to STATUS2 also.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOCK_MASK</name>
          <description>Locked Mask</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_MASK</name>
              <description>A mask that indicates which protection contexts are 'locked'.  Once locked, a protection context cannot be unlocked until the next reset or power cycle. Bit i specifies the locked status for protection context i.
0: The protection context is unlocked.
1: The protection context is locked.

When a PC is locked, the PPC_PC_MASK, PPC_NS_ATT and PPC_S_P_ATT register bits for peripheral regions to which this PC has access can no longer be modified (PPC_NS_P_ATT is not subject to these restrictions).  The one exception to this is that PPC_PC_MASK bits associated with other protection contexts that are not themselves locked can still be cleared (but not set).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_PPC</name>
          <description>Interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>SECURE_VIO</name>
              <description>HW sets this field to '1', when a security violation is detected.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_PPC_SET</name>
          <description>Interrupt set</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>SECURE_VIO</name>
              <description>Write this field with '1' to set corresponding INTR_PPC field (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_PPC_MASK</name>
          <description>Interrupt mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>SECURE_VIO</name>
              <description>Mask for corresponding field in INTR_PPC register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_PPC_MASKED</name>
          <description>Interrupt masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>SECURE_VIO</name>
              <description>Logical AND of corresponding INTR_PPC and INTR_PPC_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1024</dim>
          <dimIncrement>4</dimIncrement>
          <name>PC_MASK[%s]</name>
          <description>Protection Context Mask</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC_MASK</name>
              <description>A mask that indicates which protection contexts have access to a peripheral region.  Bit i specifies the access for protection context i.
0: The protection context has no access to this region. 
1: The protection context has access to this region, subject to secure and privilege attribute constraints setup in PPC_NS_ATT, PPC_S_P_ATT, PPC_NS_P_ATT registers)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>NS_ATT[%s]</name>
          <description>Non-secure attribute</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NS</name>
              <description>Non-Secure. Each bit indicates whether access to a peripheral region must be secure or non-secure:
IF SECURITY_AWARE=0
0 - allow only secure access to respective peripheral region.
1 - allow only non-secure access to respective peripheral region.
IF SECURITY_AWARE=1
0 - allow only secure access to respective peripheral region.
1 - allows both secure and non-secure access to respective peripheral region.
(Note that, depending on this setting the privilege access requirement for this region is specified in the corresponding PPC_S_P_ATT or PPC_NS_P_ATT register)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>S_P_ATT[%s]</name>
          <description>Secure Privilege Attribute</description>
          <addressOffset>0x2400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_P</name>
              <description>Secure Privilege. Each bit indicates whether access to a secure peripheral region requires privilege:
0 - allow only secure privileged access to respective peripheral region.
1 - allow only secure unprivileged or privileged access to respective peripheral region.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>NS_P_ATT[%s]</name>
          <description>Non-secure Privilege Attribute</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NS_P</name>
              <description>Non-Secure Privilege. Each bit indicates whether access to a non-secure peripheral region requires privilege:
0 - allow only non-secure privileged access to respective peripheral region.
1 - allow only non-secure unprivileged or privileged access to respective peripheral region.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>157</dim>
          <dimIncrement>4</dimIncrement>
          <name>R_ADDR[%s]</name>
          <description>Region Address</description>
          <addressOffset>0x00005000</addressOffset>
          <register>
            <name>R_ADDR</name>
            <description>Region Address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>R_ADDR</name>
                <description>This field specifies the base address of the peripheral region. The region size is defined by R_ATTR.R_SIZE. A region of n Bytes mus be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR must be '0's. E.g., a 64KB address region (R_SIZE is '15') must be 64 KByte aligned, and R_ADDR[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>157</dim>
          <dimIncrement>4</dimIncrement>
          <name>R_ATT[%s]</name>
          <description>Region Attribute</description>
          <addressOffset>0x00006000</addressOffset>
          <register>
            <name>R_ATT</name>
            <description>Region Attribute</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F000000</resetMask>
            <fields>
              <field>
                <name>R_SIZE</name>
                <description>This field specifies the size of the peripheral region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_PCLK</name>
      <description>Peripheral PCLK groups</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>7</dim>
          <dimIncrement>8192</dimIncrement>
          <name>GR[%s]</name>
          <description>PERI clock domains</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DIV_CMD</name>
            <description>Divider command</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF03FF</resetValue>
            <resetMask>0xC3FF03FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_DIV_SEL</name>
                <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_pclk_root[i]' is used as reference.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_TYPE_SEL</name>
                <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE</name>
                <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_pclk_root[i]' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_pclk_root[i]'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_pclk_root[i]' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>CLOCK_CTL[%s]</name>
            <description>Clock control</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_pclk_root[i]' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_8_CTL[%s]</name>
            <description>Divider control (for 8.0 divider)</description>
            <addressOffset>0x1000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT8_DIV</name>
                <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_CTL[%s]</name>
            <description>Divider control (for 16.0 divider)</description>
            <addressOffset>0x1400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_5_CTL[%s]</name>
            <description>Divider control (for 16.5 divider)</description>
            <addressOffset>0x1800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>255</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_24_5_CTL[%s]</name>
            <description>Divider control (for 24.5 divider)</description>
            <addressOffset>0x1C00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT24_DIV</name>
                <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>RAMC_PPU0</name>
      <description>Power Policy Unit Registers for System RAM</description>
      <headerStructName>RAMC_PPU</headerStructName>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWPR</name>
          <description>Power Policy Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_POLICY</name>
              <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), MEM_RET(2), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DYN_EN</name>
              <description>Power mode dynamic transition enable.  When this bit is set to 1 dynamic transitions are enabled for power modes, allowing transitions to be initiated by changes on power mode DEVACTIVE inputs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_EN</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_POLICY</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DYN_EN</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMER</name>
          <description>Power Mode Emulation Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>EMU_EN</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWSR</name>
          <description>Power Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_STATUS</name>
              <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DYN_STATUS</name>
              <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_STATUS</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_STATUS</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DYN_STATUS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DISR</name>
          <description>Device Interface Input Current Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0007FF</resetMask>
          <fields>
            <field>
              <name>PWR_DEVACTIVE_STATUS</name>
              <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DEVACTIVE_STATUS</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISR</name>
          <description>Miscellaneous Input Current Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>PCSMPACCEPT_STATUS</name>
              <description>The status of the PCSMPACCEPT input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVACCEPT_STATUS</name>
              <description>Status of the device interface DEVACCEPT inputs.  

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVDENY_STATUS</name>
              <description>Status of the device interface DEVDENY inputs.  

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STSR</name>
          <description>Stored Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STORED_DEVDENY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLK</name>
          <description>Unlock register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWCR</name>
          <description>Power Configuration Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0xFF07FFFF</resetMask>
          <fields>
            <field>
              <name>DEVREQEN</name>
              <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1. 

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DEVACTIVEEN</name>
              <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.  

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DEVACTIVEEN</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTCR</name>
          <description>Power Mode Transition Configuration Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WARM_RST_DEVREQEN</name>
              <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.  
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.  
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_RECOV_PORST_EN</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3A</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ_MASK</name>
              <description>Static full policy transition completion event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ_MASK</name>
              <description>Static transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ_MASK</name>
              <description>Static transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIMR</name>
          <description>Additional Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1E</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ_MASK</name>
              <description>Unsupported Policy event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ_MASK</name>
              <description>Dynamic transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ_MASK</name>
              <description>Dynamic transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07FFBF</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ</name>
              <description>Static full policy transition completion event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ</name>
              <description>Static transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ</name>
              <description>Static transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTHER_IRQ</name>
              <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AISR</name>
          <description>Additional Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ</name>
              <description>Unsupported Policy event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ</name>
              <description>Dynamic transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ</name>
              <description>Dynamic transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR</name>
          <description>Input Edge Sensitivity Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE00_EDGE</name>
              <description>DEVACTIVE 0 edge sensitivity.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE01_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE02_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE03_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE04_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE05_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE06_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE07_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE08_EDGE</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE09_EDGE</name>
              <description>N/A</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE10_EDGE</name>
              <description>N/A</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OPSR</name>
          <description>Operating Mode Active Edge Sensitivity Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE16_EDGE</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE17_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE18_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE19_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE20_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE21_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE22_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE23_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FUNRR</name>
          <description>Functional Retention RAM Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FUNC_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FULRR</name>
          <description>Full Retention RAM Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FULL_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMRR</name>
          <description>Memory Retention RAM Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEM_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR0</name>
          <description>Power Mode Entry Delay Register 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOGIC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR1</name>
          <description>Power Mode Entry Delay Register 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MEM_OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR0</name>
          <description>Device Control Delay Configuration Register 0</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ISO_CLKEN_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RST_HWSTAT_DLY</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR1</name>
          <description>Device Control Delay Configuration Register 1</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ISO_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKEN_ISO_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR0</name>
          <description>PPU Identification Register 0</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10530501</resetValue>
          <resetMask>0x3FF7FFFF</resetMask>
          <fields>
            <field>
              <name>DEVCHAN</name>
              <description>No. of Device Interface Channels.  The device enumeration is:
Device 0: PDCM</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_OPMODE</name>
              <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_SPT</name>
              <description>OFF support.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_EMU_SPT</name>
              <description>OFF_EMU support.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_SPT</name>
              <description>MEM_RET support.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_EMU_SPT</name>
              <description>MEM_RET_EMU support.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_LGC_RET_SPT</name>
              <description>LOGIC_RET support.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_OFF_SPT</name>
              <description>MEM_OFF support.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FULL_RET_SPT</name>
              <description>FULL_RET support.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FUNC_RET_SPT</name>
              <description>FUNC_RET support.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_ON_SPT</name>
              <description>ON support.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_WRM_RST_SPT</name>
              <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_DBG_RECOV_SPT</name>
              <description>DBG_RECOV support.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_SPT</name>
              <description>Dynamic OFF support.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_EMU_SPT</name>
              <description>Dynamic OFF_EMU support.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_SPT</name>
              <description>Dynamic MEM_RET support.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_EMU_SPT</name>
              <description>Dynamic MEM_RET_EMU support</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_LGC_RET_SPT</name>
              <description>Dynamic LOGIC_RET support.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_OFF_SPT</name>
              <description>Dynamic MEM_OFF support.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FULL_RET_SPT</name>
              <description>Dynamic FULL_RET support.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FUNC_RET_SPT</name>
              <description>Dynamic FUNC_RET support.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_ON_SPT</name>
              <description>Dynamic ON support.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_WRM_RST_SPT</name>
              <description>Dynamic WARM_RST support.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR1</name>
          <description>PPU Identification Register 1</description>
          <addressOffset>0xFB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1777</resetMask>
          <fields>
            <field>
              <name>PWR_MODE_ENTRY_DEL_SPT</name>
              <description>Power mode entry delay support.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_DEV_DEL_SPT</name>
              <description>Software device delay control configuration support.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_SPT</name>
              <description>Lock and the lock interrupt event are supported.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEM_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNC_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_SPT</name>
              <description>Power policy transition completion event status.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_SPT</name>
              <description>Operating policy transition completion event status.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_ACTIVE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFF_MEM_RET_TRANS</name>
              <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIDR</name>
          <description>Implementation Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB50043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the product.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_ID</name>
              <description>PPU part identification.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ARCH_REV_MINOR</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_REV_MAJOR</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID4</name>
          <description>Implementation Defined Identification Register (PID4)</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_11_8</name>
              <description>The JEP106 continuation code of the implementer, which is 0x4 hardcoded value.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID0</name>
          <description>Implementation Defined Identification Register (PID0)</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_7_0</name>
              <description>PPU part identification bits [7:0].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID1</name>
          <description>Implementation Defined Identification Register (PID1)</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_11_8</name>
              <description>PPU part identification bits [11:8]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER_3_0</name>
              <description>JEP106_ID bits [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID2</name>
          <description>Implementation Defined Identification Register (PID2)</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_6_4</name>
              <description>JEP106_ID bits [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONST_HIGH</name>
              <description>Constant HIGH</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV_CONST</name>
              <description>Constant LOW  Revision (4 bits)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID3</name>
          <description>Implementation Defined Identification Register (PID3)</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PID3_REV_CONST</name>
              <description>Constant LOW (4 bits)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PID3_REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID0</name>
          <description>Implementation Defined Identification Register (ID0)</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xD</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>ID0 hard coded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID1</name>
          <description>Implementation Defined Identification Register (ID1)</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xF0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID1</name>
              <description>ID1 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID2</name>
          <description>Implementation Defined Identification Register (ID2)</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID2</name>
              <description>ID2 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID3</name>
          <description>Implementation Defined Identification Register (ID3)</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID3</name>
              <description>ID3 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="RAMC_PPU0">
      <name>RAMC_PPU1</name>
      <baseAddress>0x40101000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="RAMC_PPU0">
      <name>RAMC_PPU2</name>
      <baseAddress>0x40102000</baseAddress>
    </peripheral>
    <peripheral>
      <name>ICACHE0</name>
      <description>CM33_0/1 CA APB interface</description>
      <headerStructName>ICACHE</headerStructName>
      <baseAddress>0x40103000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Cache control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xDF030003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a cache refill is done to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in STATUS0/1/2.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Cache command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of cahce and buffer. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of  buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS0</name>
          <description>Cache status 0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CTL.WAY and CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS1</name>
          <description>Cache status 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CTL.WAY and CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS2</name>
          <description>Cache status 2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.
- For cache SRAM ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ICACHE0">
      <name>ICACHE1</name>
      <baseAddress>0x40104000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CPUSS_PPU</name>
      <description>Power Policy Unit Registers for CPUSS</description>
      <baseAddress>0x40105000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWPR</name>
          <description>Power Policy Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_POLICY</name>
              <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), FULL_RET(5), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DYN_EN</name>
              <description>Power mode dynamic transition enable.  When this bit is set to 1 dynamic transitions are enabled for power modes, allowing transitions to be initiated by changes on power mode DEVACTIVE inputs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_EN</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_POLICY</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DYN_EN</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMER</name>
          <description>Power Mode Emulation Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>EMU_EN</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWSR</name>
          <description>Power Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_STATUS</name>
              <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DYN_STATUS</name>
              <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_STATUS</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_STATUS</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DYN_STATUS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DISR</name>
          <description>Device Interface Input Current Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0007FF</resetMask>
          <fields>
            <field>
              <name>PWR_DEVACTIVE_STATUS</name>
              <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DEVACTIVE_STATUS</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISR</name>
          <description>Miscellaneous Input Current Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>PCSMPACCEPT_STATUS</name>
              <description>The status of the PCSMPACCEPT input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVACCEPT_STATUS</name>
              <description>Status of the device interface DEVACCEPT inputs.  

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVDENY_STATUS</name>
              <description>Status of the device interface DEVDENY inputs.  

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STSR</name>
          <description>Stored Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STORED_DEVDENY</name>
              <description>Status of the DEVDENY signals from the last device interface Q-Channel transition.  For Q-Channel:  There is one bit for each device interface DEVQDENY.  For example, bit 0 is for Q-Channel 0 DEVQDENY, and bit 1 for Q-Channel 1 DEVQDENY.  Refer to PPU_DISR.PWR_DEVACTIVE_STATUS for device enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLK</name>
          <description>Unlock register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWCR</name>
          <description>Power Configuration Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x303</resetValue>
          <resetMask>0xFF07FFFF</resetMask>
          <fields>
            <field>
              <name>DEVREQEN</name>
              <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1. 

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DEVACTIVEEN</name>
              <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.  

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DEVACTIVEEN</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTCR</name>
          <description>Power Mode Transition Configuration Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WARM_RST_DEVREQEN</name>
              <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.  
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.  
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_RECOV_PORST_EN</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ_MASK</name>
              <description>Static full policy transition completion event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ_MASK</name>
              <description>Static transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ_MASK</name>
              <description>Static transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIMR</name>
          <description>Additional Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x6</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ_MASK</name>
              <description>Unsupported Policy event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ_MASK</name>
              <description>Dynamic transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ_MASK</name>
              <description>Dynamic transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07FFBF</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ</name>
              <description>Static full policy transition completion event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ</name>
              <description>Static transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ</name>
              <description>Static transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTHER_IRQ</name>
              <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AISR</name>
          <description>Additional Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ</name>
              <description>Unsupported Policy event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ</name>
              <description>Dynamic transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ</name>
              <description>Dynamic transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR</name>
          <description>Input Edge Sensitivity Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE00_EDGE</name>
              <description>DEVACTIVE 0 edge sensitivity.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE01_EDGE</name>
              <description>DEVACTIVE 1 edge sensitivity.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE02_EDGE</name>
              <description>DEVACTIVE 2 edge sensitivity.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE03_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE04_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE05_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE06_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE07_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE08_EDGE</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE09_EDGE</name>
              <description>N/A</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE10_EDGE</name>
              <description>N/A</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OPSR</name>
          <description>Operating Mode Active Edge Sensitivity Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE16_EDGE</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE17_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE18_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE19_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE20_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE21_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE22_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE23_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FUNRR</name>
          <description>Functional Retention RAM Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FUNC_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FULRR</name>
          <description>Full Retention RAM Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FULL_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMRR</name>
          <description>Memory Retention RAM Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEM_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR0</name>
          <description>Power Mode Entry Delay Register 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOGIC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR1</name>
          <description>Power Mode Entry Delay Register 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MEM_OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR0</name>
          <description>Device Control Delay Configuration Register 0</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ISO_CLKEN_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RST_HWSTAT_DLY</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR1</name>
          <description>Device Control Delay Configuration Register 1</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ISO_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKEN_ISO_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR0</name>
          <description>PPU Identification Register 0</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x14134102</resetValue>
          <resetMask>0x3FF7FFFF</resetMask>
          <fields>
            <field>
              <name>DEVCHAN</name>
              <description>No. of Device Interface Channels.
0: This is a P-Channel PPU.  Refer to PPU_IDR1.OP_ACTIVE for the number of DEVPACTIVE inputs and their meaning.
non-zero: The value is the number of Q-Channels.

The device enumeration is:
Device 0: SRSS PDCM,
Device 1: CPUSS SEQ between SS level LPD500 EXP &amp; PERI Q-Channel</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_OPMODE</name>
              <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_SPT</name>
              <description>OFF support.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_EMU_SPT</name>
              <description>OFF_EMU support.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_SPT</name>
              <description>MEM_RET support.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_EMU_SPT</name>
              <description>MEM_RET_EMU support.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_LGC_RET_SPT</name>
              <description>LOGIC_RET support.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_OFF_SPT</name>
              <description>MEM_OFF support.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FULL_RET_SPT</name>
              <description>FULL_RET support.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FUNC_RET_SPT</name>
              <description>FUNC_RET support.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_ON_SPT</name>
              <description>ON support.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_WRM_RST_SPT</name>
              <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_DBG_RECOV_SPT</name>
              <description>DBG_RECOV support.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_SPT</name>
              <description>Dynamic OFF support.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_EMU_SPT</name>
              <description>Dynamic OFF_EMU support.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_SPT</name>
              <description>Dynamic MEM_RET support.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_EMU_SPT</name>
              <description>Dynamic MEM_RET_EMU support</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_LGC_RET_SPT</name>
              <description>Dynamic LOGIC_RET support.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_OFF_SPT</name>
              <description>Dynamic MEM_OFF support.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FULL_RET_SPT</name>
              <description>Dynamic FULL_RET support.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FUNC_RET_SPT</name>
              <description>Dynamic FUNC_RET support.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_ON_SPT</name>
              <description>Dynamic ON support.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_WRM_RST_SPT</name>
              <description>Dynamic WARM_RST support.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR1</name>
          <description>PPU Identification Register 1</description>
          <addressOffset>0xFB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1777</resetMask>
          <fields>
            <field>
              <name>PWR_MODE_ENTRY_DEL_SPT</name>
              <description>Power mode entry delay support.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_DEV_DEL_SPT</name>
              <description>Software device delay control configuration support.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_SPT</name>
              <description>Lock and the lock interrupt event are supported.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEM_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNC_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_SPT</name>
              <description>Power policy transition completion event status.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_SPT</name>
              <description>Operating policy transition completion event status.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_ACTIVE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFF_MEM_RET_TRANS</name>
              <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIDR</name>
          <description>Implementation Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB50043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the product.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_ID</name>
              <description>PPU part identification.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ARCH_REV_MINOR</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_REV_MAJOR</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID4</name>
          <description>Implementation Defined Identification Register (PID4)</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_11_8</name>
              <description>The JEP106 continuation code of the implementer, which is 0x4 hardcoded value.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID0</name>
          <description>Implementation Defined Identification Register (PID0)</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_7_0</name>
              <description>PPU part identification bits [7:0].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID1</name>
          <description>Implementation Defined Identification Register (PID1)</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_11_8</name>
              <description>PPU part identification bits [11:8]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER_3_0</name>
              <description>JEP106_ID bits [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID2</name>
          <description>Implementation Defined Identification Register (PID2)</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_6_4</name>
              <description>JEP106_ID bits [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONST_HIGH</name>
              <description>Constant HIGH</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV_CONST</name>
              <description>Constant LOW  Revision (4 bits)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID3</name>
          <description>Implementation Defined Identification Register (PID3)</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PID3_REV_CONST</name>
              <description>Constant LOW (4 bits)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PID3_REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID0</name>
          <description>Implementation Defined Identification Register (ID0)</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xD</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>ID0 hard coded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID1</name>
          <description>Implementation Defined Identification Register (ID1)</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xF0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID1</name>
              <description>ID1 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID2</name>
          <description>Implementation Defined Identification Register (ID2)</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID2</name>
              <description>ID2 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID3</name>
          <description>Implementation Defined Identification Register (ID3)</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID3</name>
              <description>ID3 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RAMC0</name>
      <description>RAMC0/1/2</description>
      <headerStructName>RAMC</headerStructName>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10003</resetMask>
          <fields>
            <field>
              <name>SRAM_WS</name>
              <description>Wait states.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WS_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_FORCE</name>
              <description>Force EAM clock gating to be always ON.
0: Disabled
1: Enabled

This bit provides fail safe mechanism for dynamic clock gating added on EAM block.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0x11</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MACRO_CTL.OFF change this flag indicates if the new power mode has taken effect or not. 
1: Indicates change is effective;
0: Indicates change is in progress;</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_MACRO_CTL</name>
          <description>SRAM power partition power control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF</name>
              <description>Each bit represent the individual RAM power partition power state.  One bit for each macro of RAM controller when all 32 bits are populated as 32 independent power partitions.
0: Macros in power partion is to be powered-ON
1: Macros in power partion is to be powered-OFF

Note that it is not allowed to disable few macros while enable others in the same AHB write transaction.

It is mandatory to check for STATUS.PWR_DONE to become 1 once this PWR_MACRO_DTL register contents are changed to ensure SRAM mode transition is completed successfully.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_MACRO_CTL_LOCK</name>
          <description>SRAM power partition power control Lock</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MACRO_CTL_LOCK</name>
              <description>Prohibits Read/Write access to PWR_MACRO_CTL register when this field is not equal to 0.  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.
By default AHB reads/writes to PWR_MACRO_CTL register are locked.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DELAY_CTL</name>
          <description>SRAM power switch power up &amp; sequence delay</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x9020009</resetValue>
          <resetMask>0xFFFF03FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number of IMO clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ0_DELAY</name>
              <description>Number of IMO clock cycles delay needed for sequence-0 of SRAM power transition</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ1_DELAY</name>
              <description>Number of IMO clock cycles delay needed for sequence-1 of SRAM power transition</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>HW sets this field to '1', when a security violation is detected. 
SW writes '1' to this field to clear</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>SW write this field with '1' to set INTR register (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO1</name>
            <description>Infor about violation</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Full address of the access that caused violation</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO2</name>
            <description>Infor about violation</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF07FFFF</resetMask>
            <fields>
              <field>
                <name>HMASTER</name>
                <description>The master ID of the master that made the access causing the violation (taken from the AHB HMASTER signal)</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HNONSEC</name>
                <description>The security status of the access address causing the violation (taken from the AHB5 HNONSEC signal).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CFG_NS</name>
                <description>The secure/non-secure configuration of the block access attempt causing the violation.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HWRITE</name>
                <description>The R/W status from which the violating access was made.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HAUSER</name>
                <description>The protection context from which the violating access was made (taken from the AHB5 HAUSER signal).</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECURITY_VIOLATION</name>
                <description>This bit is set when a secure access was done to a non-secure block of memory, or a non-secure access was done to a secure block of memory.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACCESS_VIOLATION</name>
                <description>This bit is set when a read or write transaction was done from a protection context that does not have access to this block of memory.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CFG</name>
            <description>Sets block-size to match memory size (external memory only)</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1 MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for external memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROMC</name>
      <description>Patchable ROM Controller</description>
      <baseAddress>0x40140000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Wait states.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WS_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>HW sets this field to '1', when a security violation is detected. 
SW writes '1' to this field to clear</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>SW write this field with '1' to set INTR register (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO1</name>
            <description>Infor about violation</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Full address of the access that caused violation</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO2</name>
            <description>Infor about violation</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF07FFFF</resetMask>
            <fields>
              <field>
                <name>HMASTER</name>
                <description>The master ID of the master that made the access causing the violation (taken from the AHB HMASTER signal)</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HNONSEC</name>
                <description>The security status of the access address causing the violation (taken from the AHB5 HNONSEC signal).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CFG_NS</name>
                <description>The secure/non-secure configuration of the block access attempt causing the violation.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HWRITE</name>
                <description>The R/W status from which the violating access was made.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HAUSER</name>
                <description>The protection context from which the violating access was made (taken from the AHB5 HAUSER signal).</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECURITY_VIOLATION</name>
                <description>This bit is set when a secure access was done to a non-secure block of memory, or a non-secure access was done to a secure block of memory.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACCESS_VIOLATION</name>
                <description>This bit is set when a read or write transaction was done from a protection context that does not have access to this block of memory.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CFG</name>
            <description>Sets block-size to match memory size (external memory only)</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1 MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for external memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXCM33</name>
      <description>MXCM33-0/1</description>
      <baseAddress>0x40160000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CM33_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F001F10</resetMask>
          <fields>
            <field>
              <name>CPU_WAIT</name>
              <description>When this signal is '1' out of reset, it forces the CPU into a quiescent state that delays its boot-up sequence and instruction execution until this signal is driven '0'.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKNSVTOR</name>
              <description>Asserting this bit prevents changes to the Non-secure vector table base address.
'1': Disables writes to the VTOR_NS register.
'0': Unlocks this register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSVTAIRCR</name>
              <description>Asserting this bit prevents changes to:
- The Secure vector table base address.
- Handling of Secure interrupt priority.
- BusFault, HardFault, and NMI security target settings in the processor.
'1': Disables writes to the VTOR_S,AIRCR.PRIS, and AIRCR.BFHFNMINS registers.
'0': Unlocks these registers.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSMPU</name>
              <description>Asserting this bit prevents changes to programmed Secure MPU memory regions and all writes to the registers are ignored.
'1': Disables writes to the MPU_CTRL, MPU_RNR, MPU_RBAR,
MPU_RLAR, MPU_RBAR_An and MPU_RLAR_An from software or
from a debug agent connected to the processor in Secure state.
'0': Unlocks these registers.
This bit has no affect if the Cortex-M33 processor has not been configured with support for the Armv8-M Security Extension, or if no Secure MPU regions have been configured.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKNSMPU</name>
              <description>Asserting this bit prevents changes to Nonsecure MPU memory regions already programmed. All writes to the registers are
ignored.
'1': Disables writes to the MPU_CTRL_NS, MPU_RNR_NS, MPU_RBAR_NS, MPU_RLAR_NS, MPU_RBAR_A_NSn and
MPU_RLAR_A_NSn from software or from a debug agent connected to the processor.
'0': Unlocks these registers.
This signal has no affect if the Cortex-M33 processor has been configured without any Nonsecure MPU regions.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSAU</name>
              <description>Asserting this bit prevents changes to Secure SAU memory regions already programmed. All writes to the registers are ignored.
'1': Disables writes to the SAU_CTRL, SAU_RNR, SAU_RBAR and
SAU_RLAR registers from software or from a debug agent connected to the processor.
'0': Unlocks these registers.
This signal has no affect if the Cortex-M33 processor has not been configured with support for the Armv8-M Security Extension, or if no SAU regions have been configured.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_CMD</name>
          <description>Command</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0002</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM33 reset, followed by a CM33 warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the other CM33 while this CM33 is in Sleep or DeepSleep power mode. If this field is cleared to '0' by this CM33 itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM33 CPU has a AIRCR.SYSRESETREQ register field that allows the CM33 to reset the complete device (ENABLED only disables/enables the CM33), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_STATUS</name>
          <description>Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_INT_STATUS[%s]</name>
          <description>CM33 interrupt status</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM33 activated system interrupt index for given CPU interrupt.

Multiple system interrupts can be mapped on the same CPU interrupt. The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_NMI_CTL[%s]</name>
          <description>CM33 NMI control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_NS_VECTOR_TABLE_BASE</name>
          <description>CM33 non-secure vector table base</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>ADDR25</name>
              <description>Address of CM33 non-secure vector table to be used at reset.  The default value points to Non-secure ROM start address i.e. 0x0000_0000.</description>
              <bitRange>[31:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC_CTL</name>
          <description>CM33 protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM33_PCi_HANDLER registers:
Bit 0: Valid field for CM33_PC0_HANDLER.
Bit 1: Valid field for CM33_PC1_HANDLER.
Bit 2: Valid field for CM33_PC2_HANDLER.
Bit 3: Valid field for CM33_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC0_HANDLER</name>
          <description>CM33 protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC1_HANDLER</name>
          <description>CM33 protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC2_HANDLER</name>
          <description>CM33 protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC3_HANDLER</name>
          <description>CM33 protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_SYSTEM_INT_CTL[%s]</name>
          <description>CM33 system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 15]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.

Note: CPU_INT_IDX register width is derived from mxcm33 parameter IRQ_IDX_WIDTH. 
IRQ_IDX_WIDTH  = (CM33_INT_NR == 16) ? 4 : 3</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>DW-0/1</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40180000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
Note that DW SRAM writes/reads are possible when ENABLED=0 also.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.

Base address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.

Base address of destination location. 

Note: For a CRC transfer descriptor, this field should be programmed with the address of the CRC_LFSR_CTL register. The calculated CRC LFSR state is written to this address (through the CRYPTO AHB-Lite master interface) when the input trigger is processed. The write transfer will be submitted to the CPUSS and PERI protection schemes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.

[11:0] SRC_X_INCR
Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.

[23:12] DST_X_INCR
Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.

Note: this field is not used for CRC transfer descriptors and must be set to '0'.

[31:24] X_COUNT
Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For a single transfer descriptor type, descriptor will not have X_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.

[11:0] SRC_Y_INCR
Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[23:12] DST_Y_INCR
Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[31:24] Y_COUNT
Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For single, 1D and CRC transfer descriptor types, descriptor will not have Y_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.

[31:2] ADDR
Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000300</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hnonsec').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.

Note: protection context (PC) is routed on 'hauser' bus of the AHB5 bus.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': NO_INTR
'1': COMPLETION
'2': SRC_BUS_ERROR
'3': DST_BUS_ERROR
'4': SRC_MISAL
'5': DST_MISAL
'6': CURR_PTR_NULL
'7': ACTIVE_CH_DISABLED
'8': DESCR_BUS_ERROR
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Refer SRAM_DATA0</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>SYSCPUSS registers</description>
      <baseAddress>0x401C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO Port Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO Port Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO Port Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO Port Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_4</name>
        <description>GPIO Port Interrupt #4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <description>GPIO Port Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <description>GPIO Supply Detect Interrupt</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>Serial Communication Block #0 (DeepSleep capable)</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_backup</name>
        <description>Backup domain interrupt</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt</name>
        <description>Other combined Interrupts for srss (LVD and CLKCAL, CLKCAL only supported in Active mode)</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_dpslp_0</name>
        <description>cpuss Inter Process Communication Interrupt #0</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_dpslp_1</name>
        <description>cpuss Inter Process Communication Interrupt #1</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>keyscan_interrupt</name>
        <description>mxkeyscan interrupt for keyscan edge or fifo thresh to WIC in M33</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_wdt</name>
        <description>Interrupt from WDT</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>btss_interrupt_btss_ipc</name>
        <description>interrupt from BTSS IPC</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>Serial Communication Block #1</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>Serial Communication Block #2</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <description>cpuss DataWire #0, Channel #0</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <description>cpuss DataWire #0, Channel #1</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <description>cpuss DataWire #0, Channel #2</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <description>cpuss DataWire #0, Channel #3</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <description>cpuss DataWire #0, Channel #4</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <description>cpuss DataWire #0, Channel #5</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <description>cpuss DataWire #0, Channel #6</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <description>cpuss DataWire #0, Channel #7</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <description>cpuss DataWire #0, Channel #8</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <description>cpuss DataWire #0, Channel #9</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <description>cpuss DataWire #0, Channel #10</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <description>cpuss DataWire #0, Channel #11</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <description>cpuss DataWire #0, Channel #12</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <description>cpuss DataWire #0, Channel #13</description>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <description>cpuss DataWire #0, Channel #14</description>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <description>cpuss DataWire #0, Channel #15</description>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_mpc_promc</name>
        <description>PROMC Int</description>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_ppu_sramc0</name>
        <description>PPU SRAM0</description>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_mpc_sramc0</name>
        <description>MPC SRAM0</description>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_cm33_0_fp</name>
        <description>CM33 0 Floating Point Interrupt</description>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm33_0_cti_0</name>
        <description>CM33-0 CTI interrupt outputs</description>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm33_0_cti_1</name>
        <description>CM33-1 CTI interrupt outputs</description>
        <value>40</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_exp_br_ahb_error</name>
        <description>EXPANSION BRIDGE AHB Error interrupt</description>
        <value>41</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>42</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>43</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_256</name>
        <description>TCPWM #0, Counter #256</description>
        <value>44</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_257</name>
        <description>TCPWM #0, Counter #257</description>
        <value>45</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_258</name>
        <description>TCPWM #0, Counter #258</description>
        <value>46</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_259</name>
        <description>TCPWM #0, Counter #259</description>
        <value>47</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_260</name>
        <description>TCPWM #0, Counter #260</description>
        <value>48</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_261</name>
        <description>TCPWM #0, Counter #261</description>
        <value>49</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_262</name>
        <description>TCPWM #0, Counter #262</description>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>smif_interrupt_normal</name>
        <description>Serial Memory Interface interrupt</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>smif_interrupt_mpc</name>
        <description>Serial Memory Interface interrupt</description>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>tdm_0_interrupts_rx_0</name>
        <description>TDM0 Audio interrupt RX</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>tdm_0_interrupts_tx_0</name>
        <description>TDM0 Audio interrupt TX</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>pdm_0_interrupts_0</name>
        <description>PDM0/PCM0 Audio interrupt</description>
        <value>55</value>
      </interrupt>
      <interrupt>
        <name>pdm_0_interrupts_1</name>
        <description>PDM0/PCM0 Audio interrupt</description>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_main_ppu</name>
        <description>SRSS Main PPU Interrupt</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>peri_interrupt_ppc</name>
        <description>PERI PPC Interrupt</description>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>peri_interrupt_ahb_error</name>
        <description>PERI AHB Interrupt</description>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>lin_0_interrupts_0</name>
        <description>LIN Interrupt, Channel #0</description>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>lin_0_interrupts_1</name>
        <description>LIN Interrupt, Channel #1</description>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>crypto_interrupt_error</name>
        <description>Crypto Interrupt</description>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_ppu_cpuss</name>
        <description>CPUSS PPU Interrupt</description>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts0_0</name>
        <description>CAN #0, Interrupt #0, Channel #0</description>
        <value>64</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts1_0</name>
        <description>CAN #0, Interrupt #1, Channel #0</description>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupt0</name>
        <description>Can #0, Consolidated interrupt #0</description>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>adcmic_interrupt_adcmic</name>
        <description>ADCMIC interrupt</description>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>btss_interrupt_btss_exception</name>
        <description>interrupt indicating BTSS has encountered exception</description>
        <value>68</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID. Common ID for a product family.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.

This bit will control only the IPs which use mxambatk AHB2AHB bridge (mxambatk_ahb2ahb) and it will NOT control the buffering that may be happening in bus infrastructure components used from ARM SIE200.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFRA_CTL</name>
          <description>Infrastructure Control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CLOCK_FORCE</name>
              <description>Force Infrastructure clock gating to be always ON.
0: Disabled
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_NS_CTL</name>
          <description>Non Secure SysTick timer control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_ERROR_STATUS1</name>
          <description>AHB Error status1</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>This field indicates the AHB transaction address[31:0] that the AHB ERROR detected. This field is valid when INTR_AHB_ERROR.AHB_ERROR is set.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_ERROR_STATUS2</name>
          <description>AHB Error status2</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF7</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field indicates the atributes of AHB transaction where AHB ERROR detected. This field is valid when INTR_AHB_ERROR.AHB_ERROR is set.
P - '1' inidcates priviliged mode; '0' indicates user mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>NS - '1' indicates non secure transfer; '0' indicates secure transfer.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>W</name>
              <description>W - '1' inidicates write; '0' indicates read.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>PC - protection context</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>MS - master ID of AHB master from which transfer is initiated.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_AHB_ERROR</name>
          <description>Interrupt AHB ERROR</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when there is an AHB error response from slaves on EXPANSION bridge.

SW writes a '1' to this field to clear the interrupt cause to '0'. The HW captures a new interrupt only after clearing the interrupt cause.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET_AHB_ERROR</name>
          <description>Interrupt AHB ERROR set</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR_AHB_ERROR.AHB_ERROR field (a write of '0' has no effect).

Note that when this register is set by S/W, the AHB_ERROR_STATUS1 and AHB_ERROR_STATUS2 doesn't indicate actual cause data and these status indication needs to be ignored at that time.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK_AHB_ERROR</name>
          <description>Interrupt AHB ERROR mask</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED_AHB_ERROR</name>
          <description>Interrupt AHB ERROR masked</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>AHB_ERROR</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF70FF7</resetMask>
          <fields>
            <field>
              <name>CM33_0_ENABLE</name>
              <description>Enables the CM33_0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_ENABLE</name>
              <description>Enables the CM33_1 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DBG_ENABLE</name>
              <description>Invasive debug enable for CM33_0. 
'0': Disables all halt-mode and invasive debug features.
'1': Enables invasive debug features.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_NID_ENABLE</name>
              <description>Non-invasive debug enable for CM33_0. 
'0': Disables all trace and non-invasive debug features.
'1': Enables all trace and non-invasive debug features.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPID_ENABLE</name>
              <description>Secure invasive debug enable for CM33_0. 
'0': disables all halt mode and invasive debug features when the processor is in Secure state.
'1': Enables all halt mode and invasive debug features when the processor is in Secure state.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPNID_ENABLE</name>
              <description>Secure non-invasive debug enable for CM33_0.
'0': Disables non-invasive debug features when the processor is in Secure state.
'1': Enables non-invasive debug features when the processor is in Secure state.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DBG_ENABLE</name>
              <description>Refer CM33_0_DBG_ENABLE.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_NID_ENABLE</name>
              <description>Refer CM33_0_NID_ENABLE.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPID_ENABLE</name>
              <description>Refer CM33_0_SPID_ENABLE.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPNID_ENABLE</name>
              <description>Refer CM33_0_SPNID_ENABLE.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DISABLE</name>
              <description>Disables the CM33_0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DISABLE</name>
              <description>Disables the CM33_1 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM33_DISABLE is '0' and CM33_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DBG_DISABLE</name>
              <description>Disable Invasive debug for CM33_0. 
'1': Disables all halt-mode and invasive debug features.
'0': Enables invasive debug features.

Typically, this field is set by the Cypress boot code with information from eFUSE. The invasive debug is only enabled when CM33_0_DBG_DISABLE is '0' and CM33_0_DBG_ENABLE is '1'.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_NID_DISABLE</name>
              <description>Disable Non-invasive debug for CM33_0. 
'1': Disables all trace and non-invasive debug features.
'0': Enables all trace and non-invasive debug features.

Typically, this field is set by the Cypress boot code with information from eFUSE. The non-invasive debug is only enabled when CM33_0_NID_DISABLE is '0' and CM33_0_NID_ENABLE is '1'.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPID_DISABLE</name>
              <description>Secure invasive debug disable for CM33_0. 
'1': disables all halt mode and invasive debug features when the processor is in Secure state.
'0': Enables all halt mode and invasive debug features when the processor is in Secure state.

Typically, this field is set by the Cypress boot code with information from eFUSE. The invasive debug in secure state is only enabled when CM33_0_SPID_DISABLE is '0' and CM33_0_SPID_ENABLE is '1'.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPNID_DISABLE</name>
              <description>Secure non-invasive debug disable for CM33_0.
'1': Disables non-invasive debug features when the processor is in Secure state.
'0': Enables non-invasive debug features when the processor is in Secure state.

Typically, this field is set by the Cypress boot code with information from eFUSE. The non-invasive debug in secure state is only enabled when CM33_0_SPNID_DISABLE is '0' and CM33_0_SPNID_ENABLE is '1'.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DBG_DISABLE</name>
              <description>Refer CM33_0_DBG_DISABLE description.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_NID_DISABLE</name>
              <description>Refer CM33_0_NID_DISABLE description.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPID_DISABLE</name>
              <description>Refer CM33_0_SPID_DISABLE description.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPNID_DISABLE</name>
              <description>Refer CM33_0_SPNID_DISABLE description.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5B719A4F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0x5B719A4F': UNKNOWN.
'0x5D48F714': VIRGIN.
'0x652372F7': NORMAL.
'0x8DF117A1': SECURE.
'0x2E94B3DD': DEAD.

The following state transitions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control</description>
          <addressOffset>0x2110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MS_CTL_1_2</name>
      <description>Master control registers</description>
      <baseAddress>0x401C4000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>6</dim>
          <dimIncrement>16</dimIncrement>
          <name>MS[%s]</name>
          <description>Master protection context control</description>
          <headerStructName>MS</headerStructName>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Master 'x' protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFFFF0003</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Master security controller configuration.
0: Bus master is secure. Master can send both secure and non-secure transfers. Accesses to secure addresses are not blocked and the security flag, HNONSEC, is set accordingly. 
1: Bus master is non-secure. Master can send only non-secure
transfers. Access to secure addresses, that is, outside the
Uncheck regions, are blocked.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK</name>
                <description>Protection context mask for protection contexts '15' down to '0'. Bit PC_MASK[i] indicates if the MS_PC_STRUCT[x].PC[3:0] protection context field can be set to the value 'i':
- PC_MASK[i] is '0': MS_PC_STRUCT[x].PC[3:0] can NOT be set to 'i'; and PC[3:0] is not changed.
- PC_MASK[i] is '1': MS_PC_STRUCT[x].PC[3:0] can be set to 'i'.

Note: When CM33_0 CM33_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK[i] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 0, 1, 2 or 3 through HW (HW modifies MS_PC_STRUCT[x].PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>6</dim>
          <dimIncrement>16</dimIncrement>
          <name>MS_PC[%s]</name>
          <description>Master protection context value</description>
          <headerStructName>MS_PC</headerStructName>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>PC</name>
            <description>Master 'x' protection context value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated  MS_CTL_STRUCT[x].CTL.PC_MASK value. PC[3:0] can be set to 'i' only if the corresponding mask bit (PC_MASK[i]) is '1'.

The CM33_0 PC register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the PC field is modifiable by SW ONLY. For CM33_0 PC field HW modifications, the following holds:
* On entry of a CM33_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_PC_STRUCT[0].PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM33_PC_CTL.VALID[MS_PC_STRUCT[0].PC])
       An AHB5 bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note that the CM33_PC0/1/2/3_HANDLER and CM33_PC_CTL registers are part of mxcm33 MMIO registers.

Note: this field is NOT used by the DW controllers, DMA controllers as they inherit the protection context from master that configures the corresponding channel.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated MS_CTL_STRUCT[x].CTL.PC_MASK.

Note: this field is ONLY used by the CM33_0.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC_READ_MIR</name>
            <description>Master 'x' protection context value read mirror register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of PC.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of PC.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CODE_MS0_MSC_ACG_CTL</name>
          <description>CODE_MS0 master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_MS0_MSC_ACG_CTL</name>
          <description>SYS_MS0  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_MS1_MSC_ACG_CTL</name>
          <description>SYS_MS1  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXP_MS_MSC_ACG_CTL</name>
          <description>EXP_MS  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC0_MSC_ACG_CTL</name>
          <description>DMAC-0  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC1_MSC_ACG_CTL</name>
          <description>DMAC-1  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer 
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS_SL_CTL</name>
      <description>SYSCPUSS Internal slave control registers</description>
      <baseAddress>0x401C8000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SL_CTL</name>
          <description>Slave control (Clock enables)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7FB</resetValue>
          <resetMask>0x7FB</resetMask>
          <fields>
            <field>
              <name>PROMC_ENABLED</name>
              <description>Slave enable controls. Each bit indicates whether the respective slave is enabled or not.
0: Disabled
1: Enabled
If the slave is disabled, its clock is gated off (constant '0').
Any access (MMIO AHB access or ROM/System SRAM memory access) to slave  when disabled result in AHB error response.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASHC_ENABLED</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC2_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC_ENABLED</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SL_CTL2</name>
          <description>Slave control2 (Reset enables)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FB</resetMask>
          <fields>
            <field>
              <name>PROMC_RST</name>
              <description>Slave reset controls. Each bit indicates whether the respective slave reset is enabled or not.
0: Disabled
1: Enabled
If the slave is under reset enabled state, its clock is gated off (constant '0') and its resets are in activated state (rst_n = 0)
Any access (MMIO AHB access or ROM/System SRAM memory access) to slave  when disabled result in AHB error response.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASHC_RST</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC0_RST</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC1_RST</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC2_RST</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW0_RST</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW1_RST</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_RST</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_RST</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC_RST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x401D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier (HMASTER[MASTER_WIDTH-1:0]) that successfully acquired the lock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier (HMASTER[MASTER_WIDTH-1:0]) that successfully acquired the lock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OK</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register #2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD2_OUT</name>
              <description>HVLVD2 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or as reference inputs for the FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator #0</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>20</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>Internal High-speed Oscillator (IHO).</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>clk_pwr: used for PPU and related components</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>Internal High-speed Oscillator (IHO).</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>clk_pwr: used for PPU and related components</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>Medium Frequency Oscillator (MFO)</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>Medium Frequency Oscillator (MFO)</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete, and this case can be recovered using CAL_RESET.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_RESET</name>
              <description>Reset clock calibration logic for window mode.  This can be used to recover from unexpected conditions, such as no clock present on counter #1.
Set this bit only when CLK_CAL_TEST.CAL_WINDOW_SEL=1 (window mode).  It takes 3 clock cycles for reset to propagate.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_CLK1_PRESENT</name>
              <description>Status bit indicating that a posedge was detected by counter #1.  If this bit never asserts, there is no clock on counter #1 and CAL_COUNTER_DONE will stay low indefinitely.  This can be recovered with CAL_RESET.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000021</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AINTR</name>
              <description>See additional interrupts in SRSS_AINTR.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x21</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Set interrupt for low voltage detector WDT_MATCH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x21</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.  When WDT resets the chip, it also internally pends an interrupt that survives the reset.  To prevent unintended ISR execution, clear SRSS_INTR.WDT_MATCH before setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000021</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AINTR</name>
              <description>See additional MASKED bits in SRSS_AINTR_MASKED.ADDITIONAL</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR</name>
          <description>SRSS Additional Interrupt Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_SET</name>
          <description>SRSS Additional Interrupt Set Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Set interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_MASK</name>
          <description>SRSS Additional Interrupt Mask Register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Mask for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_MASKED</name>
          <description>SRSS Additional Interrupt Masked Register</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_DEBUG_CTL</name>
          <description>Debug Control Register</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>REQUEST</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUG_WFA</name>
              <description>Wait for Action.  Set by BootROM when it waits for application or debug certificate to be loaded into the RAM. The bit must be cleared to continue BootROM operation. It is used by the Sys-AP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_DEBUG_STATUS</name>
          <description>Debug Status Register</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_STATUS</name>
              <description>RAM application execution status. This status can be read by the debugger using Sys-AP or user application when RAM application completes with system reset. This field survives some resets, including a system reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_SOFT_CTL</name>
          <description>Soft Reset Trigger Register</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TRIGGER_SOFT</name>
              <description>Triggers a soft reset.  The reset clears this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CTL</name>
          <description>Hibernate Wakeup Mask Register</description>
          <addressOffset>0x8A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>When set, HIBERNATE will wakeup for the assigned source  The number and assignment of HIBERNATE wakeup sources are product-specific.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_CSV_BAK</name>
              <description>When set, HIBERNATE will wakeup for CSV_BAK detection.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_RTC</name>
              <description>When set, HIBERNATE will wakeup for a pending RTC interrupt.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_WDT</name>
              <description>When set, HIBERNATE will wakeup for a pending WDT interrupt.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CTL2</name>
          <description>Hibernate Wakeup Polarity Register</description>
          <addressOffset>0x8A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>Each bit selects the polarity for the corresponding HIBERNATE wakeup source.  The number and assignment of wakeup sources are product-specific.
0: Wakes when unmasked input is 0.
1: Wakes when unmasked input is 1.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CAUSE</name>
          <description>Hibernate Wakeup Cause Register</description>
          <addressOffset>0x8AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>Each bit indicates a HIBERNATE wakeup cause.  The number and assigment of wakeup sources are product-specific.  For each bit, writing a 1 clears the cause flag.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_CSV_BAK</name>
              <description>Indicates CSV_BAK wakeup cause.  The related fault must be handled before this bit can be cleared.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_RTC</name>
              <description>Indicates RTC wakeup cause.  The RTC interrupt must be cleared before this bit can be cleared.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_WDT</name>
              <description>Indicates WDT wakeup cause.  The WDT interrupt must be cleared before this bit can be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active, and current consumption may be higher than datasheet specification.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES, HIBERNATE wakeup, or supply supervision reset wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL2</name>
          <description>Power Mode Control 2</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xDF331117</resetMask>
          <fields>
            <field>
              <name>LINREG_DIS</name>
              <description>Explicitly disable the linear Core Regulator.  Write zero for Traveo II devices.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Core Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for DEEPSLEEP, HIBERNATE, and XRES low power modes.  
1: Linear Core Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccd during ACTIVE and SLEEP modes.  This setting is only legal when another source supplies vccd, but there is no special hardware protection for this case.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_OK</name>
              <description>Status of the linear Core Regulator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Regulator operates in normal mode.
1: Linear Regulator operates in low power mode.  Load current capability is reduced, and firmware must ensure the current is kept within the limit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Explicity disable the DeepSleep regulator, including circuits shared with the Active Regulator.  This register must not be set except as part of an Infineon-provided sequence or API.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: DeepSleep Regulator is not explicitly disabled.  This is the normal setting, and hardware automatically controls the DeepSleep regulator for most sequences, including for HIBERNATE and XRES low power modes.  This setting must be used if the Active Linear Regulator is used, because some circuitry is shared.
1: DeepSleep Regulator is explicitly disabled.  Only use this for special cases as part of an Infineon-provided handoff to another supply source.  For example, this setting may be used when another source supplies vccdpslp during DEEPSLEEP mode and the Active Linear Regulator is not usedfor ACTIVE/SLEEP modes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Explicitly disable the Retention regulator.  This field should normally be zero, except for special sequences provided by Infineon to use a different regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Retention Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Retention Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Retention Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccret during DEEPSLEEP mode.  This setting is only legal when another source supplies vccret, but there is no special hardware protection for this case.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Explicitly disable the Nwell regulator.  This register should normally be zero, except for special sequences provided by Infineon to use a different regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Nwell Regulator is on.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Nwell Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Nwell Regulator is explicitly disabled.  Only use this for special cases when another source supplies vnwell during DEEPSLEEP mode.  This setting is only legal when another source supplies vnwell, but there is no special hardware protection for this case.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_DIS</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_OK</name>
              <description>Indicates that the normal mode of the voltage reference is ready.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_DIS</name>
              <description>Disable the voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFVBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFVBUF_DIS=1.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_DIS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_OK</name>
              <description>Indicates that the current reference is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFI_DIS=1.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Current reference generator operates in normal mode.
1: Current reference generator operates in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: POR/BOD circuits operate in normal mode.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the circuit-level power mode of the Bandgap Reference circuits for higher operating modes than DEEPSLEEP.   This selects a second set of bandgap voltage and current generation circuits that are optimized for low current consumption.  The low current circuits are automatically used in DEEPSLEEP mode regardless of this bit.  The value in this register is ignored and higher-current mode is used until LPM_READY==1.   After this bit is set, the Active Reference circuit can be disabled to reduce current (ACT_REF_DIS=0).    Firmware is responsible to enable the Active Reference and ensure ACT_REF_OK==1 before changing back to higher current mode.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  
0: Bandgap Reference uses the normal settings.
1: Bandgap Reference uses the low power DeepSleep circuits.  Power supply rejection is reduced to save current.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE_DPSLP</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the DEEPSLEEP-RAM and DEEPSLEEP-OFF entry and exit sequences.  It is set by HW while entering DEEPSLEEP-RAM and DEEPSLEEP-OFF modes.   Writing a 1 clears freeze and GPIOs and SIOs resume normal operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  Unused, if no PLL is present in the product.
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xEFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the HIBERNATE entry and exit sequences.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.  Supply supervision is disabled during HIBERNATE mode.  HIBERNATE peripherals ignore resets (excluding XRES) while FREEZE==1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>Obsolete.  Use PWR_HIB_WAKE_CTL.HIB_WAKE_RTC for new designs.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>Obsolete.  Use PWR_HIB_WAKE_CTL.HIB_WAKE_WDT for new designs.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Obsolete.  Use PWR_HIB_WAKE_CTL2.HIB_WAKE_SRC for new designs.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>Obsolete.  Use PWR_HIB_WAKE_CTL.HIB_WAKE_SRC for new designs.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_MODE</name>
              <description>Power mode when wakeups are sensitive.  The default of this field is 0 for software compatibility with other products.  It is recommended to set this field to 1 for new/updated software.
0: Wakeups are sensitive only during HIBERNATE mode.  A wakeup pulse that comes just before HIBERNATE entry may be missed.  Backward compatible.
1: Wakeups are sensitive in HIBERNATE and higher modes.  Before entering HIBERNATE, software must clear all unmasked, pending wakeups in PWR_HIB_WAKE_CAUSE register.  An unmasked, pending wakeup causes HIBERNATE wakeup, even if it was pending from before HIBERNATE entry.  This prevents missed wakeups.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 1.0V (SISO-MC), 0.95V (SISO-LC, SIMO-LC)
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervision Control Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8080808</resetValue>
          <resetMask>0x9D909D9</resetMask>
          <fields>
            <field>
              <name>BODVDDD_VSEL</name>
              <description>Selects the voltage threshold for BOD on vddd.  The BOD does not reliably monitor the supply during the transition. 
0: vddd&lt;2.7V
1: vddd&lt;3.0V</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_VSEL</name>
              <description>Selects the voltage threshold for BOD on vdda.  Ensure BODVDDA_ENABLE==0 before changing this setting to prevent false triggers.
0: vdda&lt;2.7V
1: vdda&lt;3.0V</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_ACTION</name>
              <description>Action taken when the BOD on vdda triggers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BODVDDA_ENABLE</name>
              <description>Enable for BOD on vdda.  BODVDDA_ACTION will be triggered when the BOD is disabled.  If no action is desired when disabling, firmware must first write BODVDDA_ACTION=NOTHING in a separate write cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_VSEL</name>
              <description>Selects the voltage threshold for OVD on vddd.  The OVD does not reliably monitor the supply during the transition.
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_VSEL</name>
              <description>Selects the voltage threshold for OVD on vdda.  Ensure OVDVDDA_ENABLE==0 before changing this setting to prevent false triggers
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_ACTION</name>
              <description>Action taken when the OVD on vdda triggers.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVDVDDA_ENABLE</name>
              <description>Enable for OVD on vdda.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0x101C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x30505</resetValue>
          <resetMask>0x30707</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVDDA_OK</name>
              <description>BOD indicates vdda is ok.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.  This will always read 1, because a detected over-voltage condition will reset the chip.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDA_OK</name>
              <description>OVD indicates vdda is ok.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.    This will always read 1, because a detected over-over-voltage condition will reset the chip.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_ACT_LINREG_OK</name>
              <description>OCD indicates the current drawn from the linear Active Regulator is ok.  This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_DPSLP_REG_OK</name>
              <description>OCD indicates the current drawn from the linear DeepSleep Regulator is ok.    This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DFFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the detector (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  HVLVD1 does not function during DEEPSLEEP, but it automatically returns to its configured setting after DEEPSLEEP wakeup.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_DPSLP_EN_HT</name>
              <description>Keep HVLVD1 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EN_HT</name>
              <description>Enable HVLVD1 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register #2</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DF00</resetMask>
          <fields>
            <field>
              <name>HVLVD2_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_DPSLP_EN_HT</name>
              <description>Keep HVLVD2 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EN_HT</name>
              <description>Enable HVLVD2 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD2 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD2_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL</name>
          <description>REGHC Control Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000104</resetValue>
          <resetMask>0xFFFF7DFD</resetMask>
          <fields>
            <field>
              <name>REGHC_MODE</name>
              <description>REGHC control mode:
0: external transistor connected,
1: external PMIC connected</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_DRV_VOUT</name>
              <description>Setting for DRV_VOUT pin for PMIC mode.  See REGHC_VADJ for calculation of vadj. 
2'b00: DRV_VOUT=vccd*0.9/vadj;
2'b01: DRV_VOUT=vccd*0.8/vadj;
2'b10: DRV_VOUT=vccd*0.6/vadj;
2'b11: DRV_VOUT=vccd</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_VADJ</name>
              <description>Regulator output trim according to the formula vadj=(1.020V + REGHC_VADJ*0.005V).  The default is 1.1V.  For transistor mode, REGHC will dynamically adjust DRV_VOUT so the supply targets the vadj voltage.  For PMIC mode, see REGHC_PMIC_DRV_VOUT.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_LINREG</name>
              <description>For REGHC external PMIC mode, controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.  
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_RADJ</name>
              <description>Controls whether hardware sequencer enables reset voltage adjustment circuit when enabling a PMIC.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_RADJ</name>
              <description>Reset voltage adjustment for PMIC as a factor (Vfbk/Vref) where Vfbk is the feedback voltage and Vref is the PMIC internal reference.  The reset voltage adjustment circuit is enabled by the hardware sequencer if REGHC_PMIC_USE_RADJ=1.  PMIC have Vref of 0.8V or 0.9V, and the resulting reset voltage (Vreset) are precalculated in the table below:
3'b000: Vfbk/Vref=1.0000, Vreset=.800V@(Vref=0.8V), .900V@(Vref=0.9V);
3'b001: Vfbk/Vref=1.0556, Vreset=.844V@(Vref=0.8V), .950V@(Vref=0.9V);
3'b010: Vfbk/Vref=1.1111, Vreset=.889V@(Vref=0.8V), 1.000V@(Vref=0.9V);
3'b011: Vfbk/Vref=1.1250, Vreset=.900V@(Vref=0.8V), 1.013V@(Vref=0.9V);
3'b100: Vfbk/Vref=1.1667, Vreset=.933V@(Vref=0.8V), 1.050V@(Vref=0.9V);
3'b101: Vfbk/Vref=1.1875, Vreset=.950V@(Vref=0.8V), 1.069V@(Vref=0.9V);
3'b110: Vfbk/Vref=1.2500, Vreset=1.000V@(Vref=0.8V), 1.125V@(Vref=0.9V);
3'b111: Vfbk/Vref=1.3125, Vreset=1.050V@(Vref=0.8V), 1.181V@(Vref=0.9V);</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses REGHC_PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_TRANS_USE_OCD</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_CONFIGURED</name>
              <description>Indicates the REGHC has been configured.  This is used to know if REGHC should be enabled in response to a debug power up request.  Do not change REGHC settings after this bit is set high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_STATUS</name>
          <description>REGHC Status Register</description>
          <addressOffset>0x102C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001307</resetMask>
          <fields>
            <field>
              <name>REGHC_ENABLED</name>
              <description>Indicates the state of the REGHC enable/disable sequencer.  This bit is only valid when REGHC_SEQ_BUSY==0.
0: REGHC sequencer indicates REGHC is disabled.
1: REGHC sequencer indicates REGHC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OCD_OK</name>
              <description>Indicates the over-current detector is operating and the current drawn from REGHC is within limits.  OCD is only a choice for transistor mode, and it is disabled for PMIC mode.
0: Current measurement exceeds limit or detector is OFF,
1: Current measurement within limit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_CKT_OK</name>
              <description>Indicates the REGHC circuit is enabled and operating.  It does not indicate that the voltage and current are within required limits for robust operation.
0: REGHC circuit is not ready.  This can occur if the REGHC circuit is disabled or if it was recently enabled.
1: REGHC circuit is enabled and operating.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_UV_OUT</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OV_OUT</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to REGHC_PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (REGHC_PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_SEQ_BUSY</name>
              <description>Indicates the REGHC enable/disable sequencer is busy transitioning to/from REGHC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL2</name>
          <description>REGHC Control Register 2</description>
          <addressOffset>0x1030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>REGHC_PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for REGHC_PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.
&gt;0: enables timeout of REGHC_PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_EN</name>
              <description>Enable REGHC.  This bit will not set if REGHC_CONFIGURED==0.  Use PWR_REGHC_STATUS.ENABLED to know the actual status of REGHC.  It will differ from this bit in the following cases: 
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_REGHC_STATUS.REGHC_SEQ_BUSY).  The hardware sequencer disables REGHC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents REGHC from disabling when this bit is cleared.  Hardware does not automatically enable REGHC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL</name>
          <description>PMIC Control Register</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x104</resetValue>
          <resetMask>0xBFFF85FC</resetMask>
          <fields>
            <field>
              <name>PMIC_VREF</name>
              <description>PMIC reference voltage setting.  This selects the scaling factor used to generate the output voltage (vout) given the feedback voltage (vfb) for the chosen PMIC.  For a PMIC that compares vfb to an internal reference voltage (vref) according to the formula vout=vref/vfb, select that vref below.  For a PMIC that contains an internal resistor divider and expects an unscaled feedback voltage, use the 'No scaling' choice.
2'b00: Scale for vref=0.9V, use PMIC_VADJ to set the vccd target;
2'b01: Scale for vref=0.8V, use PMIC_VADJ to set the vccd target;
2'b10: Scale for vref=0.6V, use PMIC_VADJ to set the vccd target;
2'b11: No scaling, PMIC_VADJ has no effect</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ</name>
              <description>Voltage adjustment output setting.  The lookup table in this field requires the proper setting in PMIC_VREF for the chosen PMIC.  This field has no effect when PMIC_VREF selects no scaling.  The feedback tap point is at a vccd pad inside the chip, so the voltage may be a little higher at the PMIC output.
0x03: 1.040V, 0x04: 1.049V,
0x05: 1.057V, 0x06: 1.066V,
0x07: 1.074V, 0x08: 1.083V,
0x09: 1.091V, 0x0A: 1.099V,
0x0B: 1.108V, 0x0C: 1.116V,
0x0D: 1.125V, 0x0E: 1.133V,
0x0F: 1.142V, 0x10: 1.150V,
0x11: 1.158V, 0x12: 1.167V,
0x13: 1.175V, 0x14: 1.184V,
0x15: 1.192V, 0x16: 1.201V,
0x17: 1.209V, 0x18: 1.218V,
0x19: 1.226V, 0x1A: 1.234V,
0x1B: 1.243V, 0x1C: 1.251V,
others: Illegal.  Behavior is undefined.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_USE_LINREG</name>
              <description>Controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.  
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ_BUF_EN</name>
              <description>Analog buffer enable on voltage adjust output.  Write this bit depending on the type of PMIC connected:
0: Bypass buffer.  This connects the resistor divider directly to the output pin.  Use this setting for a PMIC with a high-impedance feedback input, such as those that support a resistor divider on the PCB.  This setting can also be used with a low-impedance PMIC with PMIC_VREF=2'b11 (no scaling).
1: Use analog buffer.  This enables an analog buffer between the resistor divider output and the pin.  The buffer can drive a resistor divider on the PCB that feeds into the PMIC feedback input.  This allows targeting a different PMIC reference voltage from PMIC_VREF choices, while still supporting voltage adjustment using the internal divider.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CONFIGURED</name>
              <description>Indicates the PMIC has been configured.  This is used to know if PMIC should be enabled in response to a debug power up request.  Do not change PMIC settings after this bit is set high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_STATUS</name>
          <description>PMIC Status Register</description>
          <addressOffset>0x10C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001001</resetMask>
          <fields>
            <field>
              <name>PMIC_ENABLED</name>
              <description>Indicates the state of the PMIC enable/disable sequencer.  This bit is only valid when PMIC_SEQ_BUSY==0.
0: PMIC sequencer indicates PMIC is disabled.
1: PMIC sequencer indicates PMIC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_SEQ_BUSY</name>
              <description>Indicates the PMIC enable/disable sequencer is busy transitioning to/from PMIC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL2</name>
          <description>PMIC Control Register 2</description>
          <addressOffset>0x10C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.  Do not change this register after setting PWR_PMIC_CTL.PMIC_CONFIGURED.
&gt;0: enables timeout of PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable PMIC.  This bit will not set if PMIC_CONFIGURED==0.  Use PWR_PMIC_STATUS.ENABLED to know the actual status of PMIC.  It will differ from this bit in the following cases: 
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_PMIC_STATUS.PMIC_SEQ_BUSY).  The hardware sequencer disables PMIC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents PMIC from disabling when this bit is cleared.  Hardware does not automatically enable PMIC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL4</name>
          <description>PMIC Control Register 4</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>PMIC_VADJ_DIS</name>
              <description>Disables the VADJ circuitry.  This can be used to decrease current consumption if the entire feedback network is outside the device.
0: Device generates VADJ when PMIC is enabled.  This allows the feedback loop to compensate for voltage drops in the PCB and package.
1: Device does not generate VADJ, and it must not be part of the PMIC feedback loop.  This reduces current by turning off the internal resistor divider that generates VADJ.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_DPSLP</name>
              <description>Configures PMIC behavior during DEEPSLEEP. 
0: Device operates from internal regulators during DEEPSLEEP.  If PMIC is enabled at the beginning of the DEEPSLEEP transition, hardware changes to the internal regulators and disables the PMIC.
1: DEEPSLEEP transition does not change PMIC enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO - Low-Power External-Crystal Oscillator</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x1240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000013F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path for HFCLK&lt;k&gt; and SRSS DSI input &lt;k&gt;.  The output of this mux goes to the direct mux (see CLK_DIRECT_SELECT).  Use CLK_SELECT_PATH[i] to configure the desired path.  The number of clock paths is product-specific, and selecting an unimplemented path is not supported.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.  This divider is after DIRECT_MUX.  For products with DSI, the output of this mux is routed to DSI for use as a signal.  For products with clock supervision, the output of this mux is the monitored clock for CSV_HF&lt;k&gt;.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRECT_MUX</name>
              <description>Deprecated.  This field is an alias for CLK_DIRECT_SELECT.DIRECT_MUX, which is preferred for new code.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Select IMO</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ROOT_MUX</name>
                  <description>Select ROOT_MUX selection</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DIRECT_SELECT[%s]</name>
          <description>Clock Root Direct Select Register</description>
          <addressOffset>0x1280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x100</resetMask>
          <fields>
            <field>
              <name>DIRECT_MUX</name>
              <description>Direct selection mux that allows IMO to bypass most of the clock mux structure.    For products with multiple regulators, this mux can be used to reduce current without requiring significant reconfiguration of the clocking network.  The default value of HFCLK&lt;0&gt;==ROOT_MUX, and the default value for other clock trees is product-specific.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Select IMO</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ROOT_MUX</name>
                  <description>Select ROOT_MUX selection</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_HF</name>
          <description>Clock Supervisor (CSV) registers for Root clocks</description>
          <headerStructName>CSV_HF</headerStructName>
          <addressOffset>0x00001400</addressOffset>
          <cluster>
            <dim>16</dim>
            <dimIncrement>16</dimIncrement>
            <name>CSV[%s]</name>
            <description>Active domain Clock Supervisor (CSV) registers</description>
            <headerStructName>CSV_HF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO, if present.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO_PRESCALER - External-Crystal Oscillator after prescaling, if present.  Does not work in DEEPSLEEP or HIBERNATE modes.  Intended for applications that operate in ACTIVE/SLEEP modes only.  This option is only valid when ECO is present in the product.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO_PRESCALER - Low-Power External-Crystal Oscillator after prescaling, if present.  This choice works in ACTIVE/SLEEP/DEEPSLEEP modes.  This option is only valid when LPECO is present in the product.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO0_CONFIG</name>
          <description>ILO0 Configuration</description>
          <addressOffset>0x1508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>ILO0_BACKUP</name>
              <description>This register indicates that ILO0 should stay enabled during XRES and HIBERNATE modes.  If backup voltage domain is implemented on the product, this bit also indicates if ILO0 should stay enabled through power-related resets on other supplies, e.g.. BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked.  This register is reset when the backup logic resets.
0: ILO0 turns off during XRES, HIBERNATE, and power-related resets.  ILO0 configuration and trims are reset by these events.
1: ILO0 stays enabled, as described above.  ILO0 configuration and trims are not reset by these events.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.

HT-variant: This register will not clear unless PWR_CTL2.BGREF_LPMODE==0. After enabling, the first ILO0 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO0 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO1_CONFIG</name>
          <description>ILO1 Configuration</description>
          <addressOffset>0x150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>ILO1_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO1.

HT-variant: After enabling, the first ILO1 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO1 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x1518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for IMO during DEEPSLEEP.  This bit configures IMO behavior during DEEPSLEEP:
0: IMO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: IMO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during HIBERNATE and XRES.  It will automatically disable during DEEPSLEEP if DPSLP_ENABLE==0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x98000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by CLK_ECO_CONFIG2.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_DISABLE</name>
              <description>ECO prescaler disable command (mutually exclusive with ECO_DIV_ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
HW sets ECO_DIV_DISABLE field to '0' immediately and HW sets CLK_ECO_PRESCALE.ECO_DIV_EN field to '0' immediately.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_ENABLE</name>
              <description>ECO prescaler enable command (mutually exclusive with ECO_DIV_DISABLE). ECO Prescaler only works in ACTIVE and SLEEP modes.  SW sets this field to '1' to enable the divider and HW sets this field to '0' to indicate that divider enabling has completed. When the divider is enabled, its integer and fractional counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the ECO_DIV_DISABLE field.
1: Configure CLK_ECO_PRESCALE registers.
2: Enable the divider using the ECO_DIV_ENABLE field.
 
HW sets the ECO_DIV_ENABLE field to '0' when the enabling is performed and HW set CLK_ECO_PRESCALER.ENABLED to '1' when the enabling is performed.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.  Configure the settings in CLK_ECO_CONFIG2 to work with the selected crystal, before enabling ECO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_PRESCALE</name>
          <description>ECO Prescaler Configuration Register</description>
          <addressOffset>0x1520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF01</resetMask>
          <fields>
            <field>
              <name>ECO_DIV_ENABLED</name>
              <description>ECO prescaler enabled. HW sets this field to '1' as a result of an CLK_ECO_CONFIG.ECO_DIV_ENABLE command. HW sets this field to '0' as a result on a CLK_ECO_CONFIG.ECO_DIV_DISABLE command.  ECO prescaler is incompatible with DEEPSLEEP modes, and firmware must disable it before entering DEEPSLEEP.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_FRAC_DIV</name>
              <description>8-bit fractional value, sufficient to get prescaler output within the +/-65ppm calibration range.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_INT_DIV</name>
              <description>10-bit integer value allows for ECO frequencies up to 33.55MHz.  Subtract one from the desired divide value when writing this field.  For example, to divide by 1, write ECO_INT_DIV=0.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x1524</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x1528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>PILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that PILO should stay enabled for use by backup domain during XRES, and HIBERNATE mode.    If backup voltage domain is implemented on the product, PILO should stay enabled through power-related resets on other supplies, e.g.. BOD on VDDD/VCCD.   If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: PILO turns off at XRES/BOD events.  (unless backup voltage domain is implemented on the product)
1: PILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_TCSC_EN</name>
              <description>PILO second order temperature curvature correction enable.  If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: Disable second order temperature curvature correction. 
1: Enable second order temperature curvature correction.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x1530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling and disabling.  Hardware handles sequencing automatically when entering/exiting DEEPSLEEP.

To enable the FLL, use the following sequence:
1) Configure FLL and CCO settings.  Do not modify CLK_FLL_CONFIG3.BYPASS_SEL (must be AUTO) or CLK_FLL_CONFIG.FLL_ENABLE (must be 0).
2) Enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1
3) Wait until CLK_FLL_STATUS.CCO_READY==1.
4) Ensure the reference clock has stabilized.
5) Write FLL_ENABLE=1.
6) Optionally wait until CLK_FLL_STATUS.LOCKED==1.  The hardware automatically changes to the FLL output when LOCKED==1.

To disable the FLL, use the following sequence:
1) Write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.
2) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).  
3) Wait at least ten cycles of either FLL reference clock or FLL output clock, whichever is slower.  
4) Disable FLL with FLL_ENABLE=0.  
5) Disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.
6) Write CLK_FLL_CONFIG3.BYPASS_SEL=AUTO.
7) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).  
8) Wait three cycles of FLL reference clock.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x1534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0xFFFF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or allow less accuracy.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
255: tolerate error of 256 count values</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_TOL</name>
              <description>Update tolerance sets the error threshold for when the FLL will update the CCO frequency settings.  The update tolerance is the allowed difference between the count value for the ideal formula and the measured value. UPDATE_TOL should be less than LOCK_TOL.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x1538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  This register can be written while the FLL is enabled.  When changing BYPASS_SEL, do not turn off the reference clock or CCO clock for five cycles (whichever is slower).  Whenever BYPASS_SEL is changed, it is required to read CLK_FLL_CONFIG3 to ensure the change takes effect.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects FLL reference input (bypass mode).  When locked, automatically selects FLL output.  This can allow some processing to occur while the FLL is locking, such as after DEEPSLEEP wakeup.  It is incompatible with clock supervision, because the frequency changes based on the lock signal.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x1540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the FLL is enabled and goes out of lock.  This bit stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG2</name>
          <description>ECO Configuration Register 2</description>
          <addressOffset>0x1544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x7FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below steady state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x1548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: ILO turns off at XRES/BOD event or HIBERNATE entry.
1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  After enabling, it takes at most two cycles to reach the accuracy spec.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO_CTL</name>
          <description>ILO Trim Register</description>
          <addressOffset>0x154C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ILO_FTRIM</name>
              <description>IL0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO0_CTL</name>
          <description>ILO0 Trim Register</description>
          <addressOffset>0x1550</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO0_FTRIM</name>
              <description>ILO0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MONTRIM</name>
              <description>ILO0 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MF_SELECT</name>
          <description>Medium Frequency Clock Select Register</description>
          <addressOffset>0x1554</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF07</resetMask>
          <fields>
            <field>
              <name>MFCLK_SEL</name>
              <description>Select source for MFCLK (clk_mf).  Note that not all products support all clock sources.  Selecting a clock source that is not supported results in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>MFO - Medium Frequency Oscillator.  DEEPSLEEP compatibility is product-specific.  See CLK_MFO_CONFIG for capability of this product.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator, if present.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO_PRESCALER - External-Crystal Oscillator, if present, after prescaling in CLK_ECO_PRESCALE.  Intended for applications that operate in ACTIVE/SLEEP modes only.  Does not work in DEEPSLEEP mode.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO - Low Power External Crystal Oscillator, if present.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFCLK_DIV</name>
              <description>Divide selected clock source by (1+MFCLK_DIV).  The output of this divider is MFCLK (clk_mf).  Allows for integer divisions in the range [1, 256].  Do not change this setting while ENABLE==1.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFCLK (clk_mf).  When disabling clk_mf, do not disable the source until after 5 clk_mf periods.  clk_mf continues to operate in DEEPSLEEP for compatible sources.  Firmware must disable clk_mf before entering DEEPSLEEP if the source is not compatible with DEEPSLEEP mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MFO_CONFIG</name>
          <description>MFO Configuration Register</description>
          <addressOffset>0x1558</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for MFO during DEEPSLEEP.  This bit is ignored when ENABLE==0.  When ENABLE==1:
0: MFO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: MFO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for Medium Frequency Oscillator (MFO) to generate clk_mf.  It is product-specific whether this is a separate component or implemented as a divided version of another clock (eg. IMO).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IHO_CONFIG</name>
          <description>IHO Configuration Register</description>
          <addressOffset>0x1560</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable for Internal High-speed Oscillator (IHO) to generate clk_iho.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ALTHF_CTL</name>
          <description>Alternate High Frequency Clock Control Register</description>
          <addressOffset>0x1564</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ALTHF_ENABLED</name>
              <description>Indicates that ALTHF is actually enabled.  The delay between a transition on ALTHF_ENABLE and ALTHF_ENABLED is product specific.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALTHF_ENABLE</name>
              <description>Enable for ALTHF clock when used by SRSS.  There may be independent control of ALTHF by another subsystem, and this bit prevents ALTHF from being disabled when SRSS needs it.  SRSS automatically removes its enable request during DEEPSLEEP and lower modes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xBE1F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_DELAY</name>
              <description>N/A</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x1640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSV_REF_SEL</name>
          <description>Select CSV Reference clock for Active domain</description>
          <addressOffset>0x1700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>REF_MUX</name>
              <description>Selects a source for clock clk_ref_hf.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.   It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_REF</name>
          <description>CSV registers for the CSV Reference clock</description>
          <headerStructName>CSV_REF</headerStructName>
          <addressOffset>0x00001710</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>Active domain Clock Supervisor (CSV) registers for CSV Reference clock</description>
            <headerStructName>CSV_REF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_LF</name>
          <description>CSV registers for LF clock</description>
          <headerStructName>CSV_LF</headerStructName>
          <addressOffset>0x00001720</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>LF clock Clock Supervisor registers</description>
            <headerStructName>CSV_LF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_ILO</name>
          <description>CSV registers for ILO clock</description>
          <headerStructName>CSV_ILO</headerStructName>
          <addressOffset>0x00001730</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>HVILO clock DeepSleep domain Clock Supervisor registers</description>
            <headerStructName>CSV_ILO_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.  ULP products: This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).

For products that support high-voltage cause detection, this bit blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_TC_DBGRESET</name>
              <description>Test controller or debugger asserted reset. Only resets debug domain.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_REF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of the reference clock source that is used to monitor the other HF clock sources.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE_EXTEND</name>
          <description>Extended Reset Cause Observation Register</description>
          <addressOffset>0x1808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x77FF0000</resetMask>
          <fields>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDA</name>
              <description>External VDDA supply crossed the brown-out limit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDA</name>
              <description>Overvoltage detection on the external VDDA supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_ACT_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the ACTIVE power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_DPSLP_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the DEEPSLEEP power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_REGHC</name>
              <description>Overcurrent detection from REGHC (if present).  If REGHC is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PMIC</name>
              <description>PMIC status triggered a reset.  If PMIC control is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PXRES</name>
              <description>PXRES triggered.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_STRUCT_XRES</name>
              <description>Structural reset was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_PXRES_CTL</name>
          <description>Programmable XRES Control Register</description>
          <addressOffset>0x1814</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PXRES_TRIGGER</name>
              <description>Triggers PXRES.  This causes a full-scope reset and reboot.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>15</dim>
          <dimIncrement>16</dimIncrement>
          <name>CLK_PLL400M[%s]</name>
          <description>400MHz PLL Configuration Register</description>
          <headerStructName>CLK_PLL400M</headerStructName>
          <addressOffset>0x00001900</addressOffset>
          <register>
            <name>CONFIG</name>
            <description>400MHz PLL Configuration Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20116</resetValue>
            <resetMask>0xB61F1FFF</resetMask>
            <fields>
              <field>
                <name>FEEDBACK_DIV</name>
                <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-15: illegal (undefined behavior)
16: divide by 16
...
200: divide by 200
&gt;200: illegal (undefined behavior)

When using fractional mode, the jitter specs are met over the restricted range of 27 to 47, inclusive.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE_DIV</name>
                <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
16: divide by 16
others: illegal (undefined behavior)

When using fractional mode, the jitter specs are met over the restricted range of 1 to 4, inclusive.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUTPUT_DIV</name>
                <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK_DELAY</name>
                <description>N/A</description>
                <bitRange>[26:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_SEL</name>
                <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCKED_OR_NOTHING</name>
                    <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_BYPASS</name>
                    <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_OUT</name>
                    <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.

fOUT = (FEEDBACK_DIV + FRAC_EN*FRAC_DIV/2^24)  * (fREF / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG2</name>
            <description>400MHz PLL Configuration Register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0FFFFFF</resetMask>
            <fields>
              <field>
                <name>FRAC_DIV</name>
                <description>Control bits for fractional divider.  This value is interpreted as a fraction of the PFD frequency, i.e. fPFD * (FRAC_DIV/2^24).  This field can be dynamically updated within the 1000ppm control limit. It takes up to 115 AHB cycles to transfer the setting to the PLL, and writes that occur faster may be silently ignored and require the application to write again after the previous update has finished.  Reading the register returns the accepted value.  The PLL will start targeting the new value, but it may take significant time (milliseconds) to stabilize at the new average value.  Do not change the FRAC_DIV setting while the PLL is initially locking.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_DITHER_EN</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_EN</name>
                <description>Enables fractional division mode.  When using fractional division mode, see CLK_PLL400M_CONFIG.LOCK_DELAY for an additional configuration requirement.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG3</name>
            <description>400MHz PLL Configuration Register 3</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x910703FF</resetMask>
            <fields>
              <field>
                <name>SSCG_DEPTH</name>
                <description>N/A</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_RATE</name>
                <description>N/A</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_DITHER_EN</name>
                <description>Enables dithering during spreading.
0: disabled
1: enabled</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_MODE</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_EN</name>
                <description>Enables spreading mode.  When using spreading, see CLK_PLL400M_CONFIG.LOCK_DELAY for an additional configuration requirement.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>400MHz PLL Status Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>LOCKED</name>
                <description>PLL Lock Indicator</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>UNLOCK_OCCURRED</name>
                <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PWR_CBUCK_CTL</name>
          <description>Core Buck Control Register</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1114</resetValue>
          <resetMask>0x1F1F</resetMask>
          <fields>
            <field>
              <name>CBUCK_VSEL</name>
              <description>Voltage output selection.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.   The actual CBUCK voltage is the maximum of this setting, the settings for all enabled step-down regulators (see PWR_SDR*_CTL), and the minimum DEEPSLEEP setting (which is not user configurable).  These settings follow the formula (0.76+0.02*CBUCK_VSEL).  
0: 0.76V, 1: 0.78V, 2: 0.80V, 3: 0.82V, 4: 0.84V, 5: 0.86V, 6: 0.88V, 7: 0.90V, 8: 0.92V, 9: 0.94V, 10: 0.96V, 11: 0.98V, 12: 1.00V, 13: 1.02V, 14: 1.04V, 15: 1.06V, 16: 1.08V, 17: 1.10V, 18: 1.12V, 19: 1.14V, 20: 1.16V, 21: 1.18V, 22: 1.20V, 23: 1.22V, 24: 1.24V, 25: 1.26V, 26: 1.28V, 27: 1.30V, 28: 1.32V, 29: 1.34V, 30: 1.36V, 31: 1.38V.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_MODE</name>
              <description>CBUCK mode.  Low ripple (high power) modes are intended for analog that needs low ripple.  Low power mode is suitable for digital processing.
The CBUCK mode is defined as = {mode*_sr_mode, mode*_sr_hp_submode[1:0], mode*_sr_lp_submode[1:0]}
The actual CBUCK mode is the maximum of this setting and the settings of all enabled step-down regulators.
0x11: HP, PFM Auto, High-Low (default Active)
0x01: LP, PFM Auto, High-Low (DeepSleep)
See s40power BROS for other settings</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_CTL2</name>
          <description>Core Buck Control Register 2</description>
          <addressOffset>0x1C04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>CBUCK_OVERRIDE</name>
              <description>Forces the CBUCK to use the settings in PWR_CBUCK_CTL register, ignoring the other hardware requests.  This can be used as part of a firmware algorithm to change the voltage of an enabled stepdown regulator.  This bit is cleared by any reset.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_PAUSE</name>
              <description>Pauses new dynamic CBUCK transitions.  An already started transition will complete, but new dynamic transitions are paused.  This can be used as part of a firmware sequence to change the voltage setting of an enabled stepdown regulator.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_COPY_SETTINGS</name>
              <description>Copies the current CBUCK composite state to the fields in  PWR_CBUCK_CTL register (CBUCK_VSEL and CBUCK_MODE).  It is recommended to pause transitions using CBUCK_PAUSE to ensure the state does not change near the copy.  After it is copied, the CBUCK_OVERRIDE bit can be used to hold the CBUCK in the current state.  Note, reading this bit always returns 0.
0: no change
1: copy settings.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_USE_SETTINGS</name>
              <description>Causes the settings in  PWR_CBUCK_CTL register to be included in the CBUCK setting decision.  Can be used to override the normal hardware voltage behavior.  Regardless of this bit, the extra settings in  PWR_CBUCK_CTL register are not used during DEEPSLEEP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_CTL3</name>
          <description>Core Buck Control Register 3</description>
          <addressOffset>0x1C08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CBUCK_INRUSH_SEL</name>
              <description>CBUCK inrush limit selection.
0: 10mA limit.
1: 100mA limit.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_STATUS</name>
          <description>Core Buck Status Register</description>
          <addressOffset>0x1C0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>PMU_DONE</name>
              <description>Indicates the power management unit is finished with a transition.
0: PMU busy
1: PMU done</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SDR0_CTL</name>
          <description>Step Down Regulator 0 Control Register</description>
          <addressOffset>0x1C10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8A09E34</resetValue>
          <resetMask>0xBCFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDR0_CBUCK_VSEL</name>
              <description>Minimum voltage selection of CBUCK when using this SDR0 (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_MODE</name>
              <description>Minimum CBUCK mode when using SDR0 (see PWR_CBUCK_CTL for mode table).
Default Active</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_DPSLP_VSEL</name>
              <description>DeepSleep voltage selection of CBUCK (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_DPSLP_MODE</name>
              <description>DeepSleep CBUCK mode when using SDR0 (see PWR_CBUCK_CTL for mode table).
Default DeepSleep</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_VSEL</name>
              <description>SDR0 output voltage.
0: 0.850V, 1: 0.875V, 2: 0.900V, 3: 0.925V, 4: 0.950V, 5: 0.975V, 6: 1.000V, 7: 1.025V, 8: 1.050V, 9: 1.075V, 10: 1.100V, 11: 1.125V, 12: 1.150V, 13: 1.175V, 14: 1.200V, 15: 1.225V</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_DPSLP_VSEL</name>
              <description>SDR0 output voltage during DeepSleep.  (See SDR0_VSEL for voltage table).</description>
              <bitRange>[29:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_ALLOW_BYPASS</name>
              <description>SDR0 bypass control.  
0: Force SDR0 to regulate.
1: Allow SDR0 to bypass if the actual CBUCK voltage matches SDR0_CBUCK_VSEL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SDR1_CTL</name>
          <description>Step Down Regulator 1 Control Register</description>
          <addressOffset>0x1C14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x400A1114</resetValue>
          <resetMask>0xC00F1F1F</resetMask>
          <fields>
            <field>
              <name>SDR1_CBUCK_VSEL</name>
              <description>Minimum voltage selection of CBUCK when using this SDR1 (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_CBUCK_MODE</name>
              <description>Minimum CBUCK mode when using SDR1 (see PWR_CBUCK_CTL for mode table).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_VSEL</name>
              <description>SDR1 output voltage.
0: 0.850V, 1: 0.875V, 2: 0.900V, 3: 0.925V, 4: 0.950V, 5: 0.975V, 6: 1.000V, 7: 1.025V, 8: 1.050V, 9: 1.075V, 10: 1.100V, 11: 1.125V, 12: 1.150V, 13: 1.175V, 14: 1.200V, 15: 1.225V</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_HW_SEL</name>
              <description>Selects hardware control for SDR1.  
0: SDR1_ENABLE controls SDR1.  Hardware controls are ignored.
1: SDR1_ENABLE is ignored and a hardware signal is used instead.  Selecting this on products that don't have supporting hardware will disable SDR1.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_ENABLE</name>
              <description>Enable for SDR1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HVLDO0_CTL</name>
          <description>HVLDO0 Control Register</description>
          <addressOffset>0x1C30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000007</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>HVLDO0_VSEL</name>
              <description>HVLDO0 output voltage.
0: 1.8V, 1: 1.9V, 2: 2.0V, 3: 2.1V, 4: 2.2V, 5: 2.3V, 6: 2.4V, 7: 2.5V, 8: 2.6V, 9: 2.7V, 10: 2.8V, 11: 2.9V, 12: 3.0V, 13: 3.1V, 14: 3.2V, 15: 3.3V</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLDO0_HW_SEL</name>
              <description>Selects hardware control for HVLDO0.  
0: HVLDO0_ENABLE controls SDR1.  Hardware controls are ignored.
1: HVLDO0_ENABLE is ignored and a hardware signal is used instead.  Selecting this on products that don't have supporting hardware will disable HVLDO0.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLDO0_ENABLE</name>
              <description>HVLDO0 enable</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_XRES_SECURE</name>
          <description>SECURE TEST and FIRMWARE TEST Key control register</description>
          <addressOffset>0x2054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE00F0FFF</resetMask>
          <fields>
            <field>
              <name>DATA8</name>
              <description>Data byte to be set into either SECURE TEST or FIRMWARE TEST key.  Must not be changed in the same write that is toggling any of the *_WR bits below,</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit FIRMWARE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SECURE_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit SECURE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_KEY_OK</name>
              <description>Indicates that the 32-bit FIRMWARE TEST key is observing the correct key.  Firmware key is reset by (A)XRES and STRUCT_XRES.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_KEY_OK</name>
              <description>Indicates that the 32-bit SECURE TEST key is observing the correct key.  Secure key is not reset, but it will establish low after a deep power cycle that causes it to lose its written state.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_DISABLE</name>
              <description>Disables the SECURE TEST key entry capability until next reset.   Must not be set in the same write when any of the above *_WR bits are set or toggling.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_CBUCK_CTL</name>
          <description>CBUCK Trim Register</description>
          <addressOffset>0x20AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1F1F</resetMask>
          <fields>
            <field>
              <name>CBUCK_DPSLP_VSEL</name>
              <description>The CBUCK voltage setting to use during DEEPSLEEP.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_DPSLP_MODE</name>
              <description>The CBUCK mode setting to use during DEEPSLEEP.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ECO_CTL</name>
          <description>ECO Trim Register</description>
          <addressOffset>0x301C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F0000</resetValue>
          <resetMask>0x3F0000</resetMask>
          <fields>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO1_CTL</name>
          <description>ILO1 Trim Register</description>
          <addressOffset>0x3220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO1_FTRIM</name>
              <description>ILO1 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO1_MONTRIM</name>
              <description>ILO1 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTL</name>
          <description>Watchdog Counter Control Register (Type A)</description>
          <addressOffset>0xC000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC0000031</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Enable this watchdog timer.  This field is retained during DEEPSLEEP and HIBERNATE modes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CLK_SEL</name>
              <description>Select source for WDT.  Not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlock using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, if present</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>BAK - Selected clk_bak source, if present.  See BACKUP_CTL.  This choice is not recommended for applications that rely upon the watchdog timer for safety or security, unless the product supports clock supervision of clk_bak (CSV_BAK).  Generation of clk_bak is not protected by WDT_LOCK and is in a different memory region with potentially different security attributes.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during DEEPSLEEP or HIBERNATE mode, so the WDT will be locked after wakeup from these modes.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CNT</name>
          <description>Watchdog Counter Count Register (Type A)</description>
          <addressOffset>0xC004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter.  The write feature of this register is for engineering use (DfV), have no synchronization, and can only be applied when the WDT is fully off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negedge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Counter Match Register (Type A)</description>
          <addressOffset>0xC008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH2</name>
          <description>Watchdog Counter Match Register 2 (Type A)</description>
          <addressOffset>0xC00C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>IGNORE_BITS_ABOVE</name>
              <description>The bit index to be considered the MSB for matching.  Bit indices above this setting are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  The four LSBs cannot be ignored for matching.  Settings &lt;3 behave like a setting of 3.  If the setting is higher than the number of bits in the WDT counter, all actual bits in the counter are matched.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MCWDT_STRUCT</name>
          <description>Multi-Counter Watchdog Timer (Type A)</description>
          <headerStructName>MCWDT_STRUCT</headerStructName>
          <addressOffset>0x0000D000</addressOffset>
          <register>
            <name>MCWDT_CNTLOW</name>
            <description>Multi-Counter Watchdog Sub-counters 0/1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR0</name>
                <description>Current value of sub-counter 0 for this MCWDT.  Software writes are ignored when the sub-counter is enabled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CTR1</name>
                <description>Current value of sub-counter 1 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CNTHIGH</name>
            <description>Multi-Counter Watchdog Sub-counter 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR2</name>
                <description>Current value of sub-counter 2 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_MATCH</name>
            <description>Multi-Counter Watchdog Counter Match Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MATCH0</name>
                <description>Match value for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1</name>
                <description>Match value for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CONFIG</name>
            <description>Multi-Counter Watchdog Counter Configuration</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F01FFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MODE0</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR0=WDT_MATCH0).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR0</name>
                <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH0 is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE0_1</name>
                <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_MODE0</name>
                <description>Watchdog Counter Action on service before lower limit.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CARRY0_1</name>
                <description>Carry out behavior that applies when WDT_CASCADE0_1==1.  This bit is not used when WDT_CASCADE0_1==0.
0: carry out on counter 0 match.
1: carry out on counter 0 roll-over.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH0_1</name>
                <description>Specifies matching behavior when WDT_CASCADE0_1==1.  When WDT_CASCADE0_1==0, this bit is not used and match is based on counter 1 alone.
0: Match based on counter 1 alone.
1: Match based on counter 1 and counter 0 matching simultaneously.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE1</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR1=WDT_MATCH1).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR1</name>
                <description>Clear Watchdog Counter when WDT_CTR1==WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH1 is 1.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE1_2</name>
                <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_MODE1</name>
                <description>Watchdog Counter Action on service before lower limit.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CARRY1_2</name>
                <description>Carry out behavior that applies when WDT_CASCADE1_2==1.  This bit is not used when WDT_CASCADE1_2==0.
0: carry out on counter 1 match.
1: carry out on counter 1 roll-over.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1_2</name>
                <description>Specifies matching behavior when WDT_CASCADE1_2==1.  When WDT_CASCADE1_2==0, this bit is not used and match is based on counter 2 alone.
0: Match based on counter 2 alone.
1: Match based on counter 2 and counter 1 matching simultaneously.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE2</name>
                <description>Watchdog Counter 2 Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Free running counter with no interrupt requests</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Free running counter with interrupt request that occurs one LFCLK cycle after the specified bit in CTR2 toggles (see WDT_BITS2).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_BITS2</name>
                <description>Bit to observe for WDT_INT2:
0: Assert after bit0 of WDT_CTR2 toggles (one int every tick)
...
31: Assert after bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CTL</name>
            <description>Multi-Counter Watchdog Counter Control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB0B0B</resetMask>
            <fields>
              <field>
                <name>WDT_ENABLE0</name>
                <description>Enable subcounter 0.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED0</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to two LFCLK cycles.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET0</name>
                <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE1</name>
                <description>Enable subcounter 1.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED1</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to two LFCLK cycles.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET1</name>
                <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE2</name>
                <description>Enable subcounter 2.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED2</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to two LFCLK cycles.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET2</name>
                <description>Resets counter 2 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR</name>
            <description>Multi-Counter Watchdog Counter Interrupt Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE0=3.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE1=3.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE2=3.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_SET</name>
            <description>Multi-Counter Watchdog Counter Interrupt Set Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASK</name>
            <description>Multi-Counter Watchdog Counter Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Mask for sub-counter 0. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Mask for sub-counter 1. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Mask for sub-counter 2. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASKED</name>
            <description>Multi-Counter Watchdog Counter Interrupt Masked Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOCK</name>
            <description>Multi-Counter Watchdog Counter Lock Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC0000000</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.  LFCLK settings are locked by the global WDT_LOCK register, and this register has no effect on that.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOWER_LIMIT</name>
            <description>Multi-Counter Watchdog Counter Lower Limit Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_LOWER_LIMIT0</name>
                <description>Lower limit for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_LIMIT1</name>
                <description>Lower limit for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWRMODE</name>
      <description>SRSS Power Mode Control Registers</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>16</dimIncrement>
          <name>PD[%s]</name>
          <description>Power Domain Dependency Sense Register</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PD_SENSE</name>
            <description>Dependency Sense Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PD_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; is directly kept on when PD&lt;i&gt; is on.  Indirect dependency is still possible if multiple direct dependencies work together to create a transitive relationship.  For example, if PD1 depends upon PD2; and PD2 dpends upon PD3; then PD1 indirectly depends upon PD3 regardless of whether there is a direct dependency from PD3 to PD1.  Some bits are implemented as constants, and some bits are implemented as user-configurable registers.  Refer to PD_SPT register to see how each bit is implemented.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PD_SPT</name>
            <description>Dependency Support Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PD_FORCE_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; is always kept on when PD&lt;i&gt; is on for sense bits that are not configurable.  For configurable bits, this indicates the reset value of the configurable bit.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PD_CONFIG_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; can be configured on when PD&lt;i&gt; is on.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>PPU_MAIN</name>
          <description>Power Policy Unit for Active Domain</description>
          <addressOffset>0x00001000</addressOffset>
          <cluster>
            <name>PPU_MAIN</name>
            <description>Power Policy Unit Registers for the main power domain (VCCACT_PD)</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>PWPR</name>
              <description>Power Policy Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x108</resetValue>
              <resetMask>0x10F110F</resetMask>
              <fields>
                <field>
                  <name>PWR_POLICY</name>
                  <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), MEM_RET(2), FULL_RET(5), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWR_DYN_EN</name>
                  <description>Power mode dynamic transition enable.  For main PPU, keep this bit 1.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCK_EN</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_POLICY</name>
                  <description>N/A</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_DYN_EN</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PMER</name>
              <description>Power Mode Emulation Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>EMU_EN</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PWSR</name>
              <description>Power Status Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x10F110F</resetMask>
              <fields>
                <field>
                  <name>PWR_STATUS</name>
                  <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PWR_DYN_STATUS</name>
                  <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LOCK_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_DYN_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DISR</name>
              <description>Device Interface Input Current Status Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF0007FF</resetMask>
              <fields>
                <field>
                  <name>PWR_DEVACTIVE_STATUS</name>
                  <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_DEVACTIVE_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MISR</name>
              <description>Miscellaneous Input Current Status Register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF01</resetMask>
              <fields>
                <field>
                  <name>PCSMPACCEPT_STATUS</name>
                  <description>The status of the PCSMPACCEPT input.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEVACCEPT_STATUS</name>
                  <description>Status of the device interface DEVACCEPT inputs.  

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEVDENY_STATUS</name>
                  <description>Status of the device interface DEVDENY inputs.  

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STSR</name>
              <description>Stored Status Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>STORED_DEVDENY</name>
                  <description>Status of the DEVDENY signals from the last device interface Q-Channel transition.  For Q-Channel:  There is one bit for each device interface DEVQDENY.  For example, bit 0 is for Q-Channel 0 DEVQDENY, and bit 1 for Q-Channel 1 DEVQDENY.  Refer to PPU_DISR.PWR_DEVACTIVE_STATUS for device enumeration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>UNLK</name>
              <description>Unlock register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>UNLOCK</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PWCR</name>
              <description>Power Configuration Register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x101</resetValue>
              <resetMask>0xFF07FFFF</resetMask>
              <fields>
                <field>
                  <name>DEVREQEN</name>
                  <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1. 

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWR_DEVACTIVEEN</name>
                  <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.  

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[18:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_DEVACTIVEEN</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTCR</name>
              <description>Power Mode Transition Configuration Register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>WARM_RST_DEVREQEN</name>
                  <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.  
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.  
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBG_RECOV_PORST_EN</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IMR</name>
              <description>Interrupt Mask Register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>STA_POLICY_TRN_IRQ_MASK</name>
                  <description>Static full policy transition completion event mask.  For main PPU, this bit has no function because no static transitions are supported (see PWPR.PWR_DYN_EN).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_ACCEPT_IRQ_MASK</name>
                  <description>Static transition acceptance event mask.  For main PPU, keep this bit 1 to mask the event, otherwise the interrupt may trigger a wakeup.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_DENY_IRQ_MASK</name>
                  <description>Static transition denial event mask.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_ACCEPT_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_DENY_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCKED_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AIMR</name>
              <description>Additional Interrupt Mask Register</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>UNSPT_POLICY_IRQ_MASK</name>
                  <description>Unsupported Policy event mask.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_ACCEPT_IRQ_MASK</name>
                  <description>Dynamic transition acceptance event mask.  For main PPU, keep this bit 1 to mask the event, otherwise the interrupt that occurs when entering a low power mode may trigger a wakeup.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_DENY_IRQ_MASK</name>
                  <description>Dynamic transition denial event mask.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ISR</name>
              <description>Interrupt Status Register</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF07FFBF</resetMask>
              <fields>
                <field>
                  <name>STA_POLICY_TRN_IRQ</name>
                  <description>Static full policy transition completion event status.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_ACCEPT_IRQ</name>
                  <description>Static transition acceptance event status.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_DENY_IRQ</name>
                  <description>Static transition denial event status.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_ACCEPT_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_DENY_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCKED_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OTHER_IRQ</name>
                  <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PWR_ACTIVE_EDGE_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[18:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_ACTIVE_EDGE_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AISR</name>
              <description>Additional Interrupt Status Register</description>
              <addressOffset>0x3C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>UNSPT_POLICY_IRQ</name>
                  <description>Unsupported Policy event status.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_ACCEPT_IRQ</name>
                  <description>Dynamic transition acceptance event status.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_DENY_IRQ</name>
                  <description>Dynamic transition denial event status.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IESR</name>
              <description>Input Edge Sensitivity Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>DEVACTIVE00_EDGE</name>
                  <description>DEVACTIVE 0 edge sensitivity.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE01_EDGE</name>
                  <description>DEVACTIVE 1 edge sensitivity.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE02_EDGE</name>
                  <description>DEVACTIVE 2 edge sensitivity.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE03_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE04_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE05_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE06_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE07_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE08_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE09_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[19:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE10_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>OPSR</name>
              <description>Operating Mode Active Edge Sensitivity Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>DEVACTIVE16_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE17_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE18_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE19_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE20_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE21_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE22_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE23_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>FUNRR</name>
              <description>Functional Retention RAM Configuration Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>FUNC_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>FULRR</name>
              <description>Full Retention RAM Configuration Register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>FULL_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MEMRR</name>
              <description>Memory Retention RAM Configuration Register</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>MEM_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EDTR0</name>
              <description>Power Mode Entry Delay Register 0</description>
              <addressOffset>0x160</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>OFF_DEL</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MEM_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOGIC_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FULL_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EDTR1</name>
              <description>Power Mode Entry Delay Register 1</description>
              <addressOffset>0x164</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>MEM_OFF_DEL</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FUNC_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCDR0</name>
              <description>Device Control Delay Configuration Register 0</description>
              <addressOffset>0x170</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CLKEN_RST_DLY</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ISO_CLKEN_DLY</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RST_HWSTAT_DLY</name>
                  <description>N/A</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCDR1</name>
              <description>Device Control Delay Configuration Register 1</description>
              <addressOffset>0x174</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>ISO_RST_DLY</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CLKEN_ISO_DLY</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IDR0</name>
              <description>PPU Identification Register 0</description>
              <addressOffset>0xFB0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x14534501</resetValue>
              <resetMask>0x3FF7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEVCHAN</name>
                  <description>No. of Device Interface Channels.
0: This is a P-Channel PPU.  Refer to PPU_IDR1.OP_ACTIVE for the number of DEVPACTIVE inputs and their meaning.
non-zero: The value is the number of Q-Channels.

The device enumeration is:
Device 0: PDCM</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NUM_OPMODE</name>
                  <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_OFF_SPT</name>
                  <description>OFF support.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_OFF_EMU_SPT</name>
                  <description>OFF_EMU support.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_RET_SPT</name>
                  <description>MEM_RET support.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_RET_EMU_SPT</name>
                  <description>MEM_RET_EMU support.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_LGC_RET_SPT</name>
                  <description>LOGIC_RET support.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_OFF_SPT</name>
                  <description>MEM_OFF support.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_FULL_RET_SPT</name>
                  <description>FULL_RET support.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_FUNC_RET_SPT</name>
                  <description>FUNC_RET support.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_ON_SPT</name>
                  <description>ON support.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_WRM_RST_SPT</name>
                  <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_DBG_RECOV_SPT</name>
                  <description>DBG_RECOV support.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_OFF_SPT</name>
                  <description>Dynamic OFF support.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_OFF_EMU_SPT</name>
                  <description>Dynamic OFF_EMU support.</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_RET_SPT</name>
                  <description>Dynamic MEM_RET support.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_RET_EMU_SPT</name>
                  <description>Dynamic MEM_RET_EMU support</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_LGC_RET_SPT</name>
                  <description>Dynamic LOGIC_RET support.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_OFF_SPT</name>
                  <description>Dynamic MEM_OFF support.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_FULL_RET_SPT</name>
                  <description>Dynamic FULL_RET support.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_FUNC_RET_SPT</name>
                  <description>Dynamic FUNC_RET support.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_ON_SPT</name>
                  <description>Dynamic ON support.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_WRM_RST_SPT</name>
                  <description>Dynamic WARM_RST support.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IDR1</name>
              <description>PPU Identification Register 1</description>
              <addressOffset>0xFB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1777</resetMask>
              <fields>
                <field>
                  <name>PWR_MODE_ENTRY_DEL_SPT</name>
                  <description>Power mode entry delay support.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SW_DEV_DEL_SPT</name>
                  <description>Software device delay control configuration support.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LOCK_SPT</name>
                  <description>Lock and the lock interrupt event are supported.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MEM_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FULL_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FUNC_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ_SPT</name>
                  <description>Power policy transition completion event status.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ_SPT</name>
                  <description>Operating policy transition completion event status.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_ACTIVE</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OFF_MEM_RET_TRANS</name>
                  <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IIDR</name>
              <description>Implementation Identification Register</description>
              <addressOffset>0xFC8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0xB50043B</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>IMPLEMENTER</name>
                  <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
                  <bitRange>[11:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REVISION</name>
                  <description>Minor revision of the product.</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VARIANT</name>
                  <description>Major revision of the product.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRODUCT_ID</name>
                  <description>PPU part identification.</description>
                  <bitRange>[31:20]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AIDR</name>
              <description>Architecture Identification Register</description>
              <addressOffset>0xFCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x11</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>ARCH_REV_MINOR</name>
                  <description>N/A</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ARCH_REV_MAJOR</name>
                  <description>N/A</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Selection for Power Mode Components</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>CLK_PWR_DIV</name>
              <description>clk_pwr is generated by dividing the CLK_PWR_MUX selection by (CLK_PWR_DIV+1).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PWR_MUX</name>
              <description>Selects a source for the clock used by power control components.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Registers</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3708</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.  Follow the procedure in BACKUP_RTC_RW to access this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for RTC clock</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock. Note that LFCLK is only available in Active and DeepSleep power modes.
Note that LFCLK clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO or ILO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low frequency Oscillator, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.
For Hibernate operation CLK_ILO0_CONFIG. ILO_BACKUP must be set.  If there are multiple ILO, this is ILO0.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>Low-power external crystal oscillator prescaler output, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision internal low-speed oscillator, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled to 10 percent of vbackup, so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
Only user RTC registers that were written to will get copied, others will not be affected. 
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB003007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)) when CAL_COMP_PER_MIN is set at default value.
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field) when CAL_COMP_PER_MIN is set at default value .

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments when CAL_COMP_PER_MIN is set at default value .</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COMP_PER_MIN</name>
              <description>Select how many time calibration is performed per minute  per step of 64 , each time a 64 step is added or substracted one unit 2/4/8/16*CALIB_VAL is substracted.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2</name>
                  <description>Calibration of 64 each is performed twice per minute for 2*CALIB_VAL per hour</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4</name>
                  <description>Calibration of 64 each is performed four times per minute for 4*CALIB_VAL per hour</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8</name>
                  <description>Calibration of 64 each is performed eight  times per minute for 8*CALIB_VAL per hour</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>16</name>
                  <description>Calibration of 64 each is performed sixteen times per minute for 16*CALIB_VAL per hour</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_SEL</name>
              <description>Select calibration wave output signal</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAL512</name>
                  <description>512Hz wave, not affected by calibration setting (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL2</name>
                  <description>2Hz wave, includes the effect of the calibration setting, (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL1</name>
                  <description>1Hz wave, includes the effect of the calibration setting (supported for all input clocks)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for wave signal for calibration and allow CALIB_VAL to be written.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>Pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Obsolete.  Use WCO_STATUS.WCO_OK for future designs.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x75F3F3F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours, value depending on 12/24HR mode
0=24HR: [20:16]=0-23
1=12HR: [20]:0=AM, 1=PM, [19:16]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x7F0F1F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year, 0-99</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WCO_STATUS</name>
          <description>WCO Status Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x4</resetMask>
          <fields>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET0[%s]</name>
          <description>Backup register region 0</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET1[%s]</name>
          <description>Backup register region 1</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET2[%s]</name>
          <description>Backup register region 2</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTOLITE</name>
      <description>N/A</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the P field for the user/privileged access control ('hprot[1]').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes  any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the NS field for the secure/non-secure access control ('hprot[4]').</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Protection context.

This field is set with the protection context of the transaction that writes any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the PC field for the protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>Master identifier of the cryptography IP. This is a design time configurable parameter.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy indication:
'0': IP not busy.
'1': IP busy (AES, SHA or VU functionality (TRNG functionality NOT included)).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SHA_DESCR</name>
          <description>SHA descriptor pointer</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>SHA-256 descriptor pointer. The descriptor points to a structure with 32-bit words:
For message schedule function: 
Word 0: Control word.
- WORD0[28]: '0' for message schedule function.
Word 1: Pointer to 512 b message chunk (input).
Word 2: Pointer to 64 * 32 b word message schedule array (output).
For process function:
Word 0: Control word. 
- WORD0[28]: '1' for process function.
Word 1: Pointer to 8 * 32 b word current hash value (input) and new hash value (output).
Word 2: Pointer to 64 * 32 b word message schedule array (input).

A write to this register automatically starts a SHA-256 operation. The write ONLY takes effect when the IP is NOT busy (STATUS.BUSY is '0'). The write will be made pending/blocked as long as the IP is busy.

Note: the pointers must be 32-bit word aligned.

Note: HW updates this field when the SHA-256 engine is busy.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR</name>
          <description>Error interrupt</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>AHB-Lite master interface bus error or ECC error. Note that the IP terminates its AES, SHA or VU functionality when it detects an error.

Note: The error is sticky. This allows SW to check for an error after a series of operations, rather than checking after every individual operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_SET</name>
          <description>Error interrupt set</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Write this field with '1' to set corresponding INTR_ERROR field to '1' (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_MASK</name>
          <description>Error interrupt mask</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Mask for corresponding field in INTR_ERROR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_MASKED</name>
          <description>Error interrupt masked</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Logical and of corresponding INTR_ERROR and INTR_ERROR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>IO Matrix (IOM)</description>
      <baseAddress>0x40400000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>6</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pin 0 route.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pin 1 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pin 2 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pin 3 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pin 4 route.
See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pin 5 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pin 6 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pin 7 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>IO port control/configuration</description>
      <baseAddress>0x40410000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>6</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.
On reset assertion , IN register will get reset. The Pad value takes 2 clock cycles to be reflected into IN Register.  The default value is transient.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Weak/resistive pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull up
   D_OUT = '1': Weak/resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Weak/resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': High Impedance
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': High Impedance
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = '0':
    GPIO_DSI_OUT = '0': Weak/resistive pull down
    GPIO_DSI_OUT = '1': Weak/resistive pull up
where 'GPIO_DSI_OUT' is a function of PORT_SEL, OUT &amp; DSI_DATA_OUT.

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
    D_OUT = '0': Weak/resistive pull down
    D_OUT = '1': Weak/resistive pull up</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>Input buffer compatible with CMOS and I2C interfaces</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>Input buffer compatible with TTL and MediaLB interfaces</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>Selects the output buffer mode:
'0': Unregulated output buffer
'1': Regulated output buffer
The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode. If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>Selects the input buffer mode:
0: Singled ended input buffer
1: Differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>Selects the input buffer trip-point in single ended input buffer mode (IBUF_SEL = '0'):
'0': Input buffer functions as a CMOS input buffer.
'1': Input buffer functions as a TTL input buffer.
In differential input buffer mode (IBUF_SEL = '1')
'0': Trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': Trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>Selects reference voltage (Vref) trip-point of the input buffer:
'0': Trip-point reference from pin_ref
'1': Trip-point reference of SRSS internal reference Vref (1.2 V)
'2': Trip-point reference of AMUXBUS_A
'3': Trip-point reference of AMUXBUS_B</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects the regulated Voh output level and trip point of the input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
'0': Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
'1': Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
'2': Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
'3': Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
'4': Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
'5': Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
'6': Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
'7': Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on Voh is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register for S40E GPIO</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for S40E GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with MediaLB.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO_OR_MediaLB</name>
                    <description>Input buffer compatible with AUTO/MediaLB (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT2</name>
            <description>Port output buffer configuration register 2</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DS_TRIM0</name>
                <description>Sets the Drive Select Trim for  IO pin 0
0 - Default (50ohms)
1 - 120ohms
2 - 90ohms
3 - 60ohms
4 - 50ohms
5 - 30ohms
6 - 20ohms
7 - 15ohms</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DEFAULT</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_120OHM</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_90OHM</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_60OHM</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_50OHM</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_30OHM</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_20OHM</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_15OHM</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS_TRIM1</name>
                <description>Sets the Drive Select Trim for IO pin 1</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM2</name>
                <description>Sets the Drive Select Trim for IO pin 2</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM3</name>
                <description>Sets the Drive Select Trim for IO pin 3</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM4</name>
                <description>Sets the Drive Select Trim for IO pin 4</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM5</name>
                <description>Sets the Drive Select Trim for IO pin 5</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM6</name>
                <description>Sets the Drive Select Trim for IO pin 6</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM7</name>
                <description>Sets the Drive Select Trim for IO pin 7</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SLEW_EXT</name>
            <description>Port output buffer slew extension configuration register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>SLEW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW1</name>
                <description>Slew rate for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW2</name>
                <description>Slew rate for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW3</name>
                <description>Slew rate for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW4</name>
                <description>Slew rate for IO pin 4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW5</name>
                <description>Slew rate for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW6</name>
                <description>Slew rate for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW7</name>
                <description>Slew rate for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT0</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT1</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x8004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x8008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x800C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x8010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x8014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x8018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x801C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x8020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed). 
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.  
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LIN0</name>
      <description>LIN</description>
      <headerStructName>LIN</headerStructName>
      <baseAddress>0x40430000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ERROR_CTL</name>
          <description>Error control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80EF001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which HW  injected channel transmitter errors applies.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_ERROR</name>
              <description>The synchronization field is changed from 0x55 to 0x00.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR activation.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_STOP_ERROR</name>
              <description>The synchronization field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR or INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PARITY_ERROR</name>
              <description>In LIN mode, the PID parity bit P[1] is inverted from !(ID[5] ^ ID[4] ^ ID[3] ^ ID[1]) to (ID[5] ^ ID[4] ^ ID[3] ^ ID[1]).

At the receiver, this should result in INTR.RX_HEADER_PARITY_ERROR activation.

In UART mode, a data field's parity bit is inverted.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PID_STOP_ERROR</name>
              <description>The PID field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_STOP_ERROR</name>
              <description>The data field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.

Note: Used in UART mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_ERROR</name>
              <description>The checksum field is inverted.

At the receiver, this should result in INTR.RX_RESPONSE_CHECKSUM_ERROR activation.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_STOP_ERROR</name>
              <description>The checksum field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8001001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which test applies. The channel IO signals of channel indices CH_IDX and CH_NR-1 are connected as specified by MODE. CH_IDX should be in the range [0, CH_NR-2], as channel index CH_NR-1 is always involved in test and cannot be connected to itself. The test mode allows BOTH of the two connected channels to be tested.

Note: this testing functionality simplifies SW development, but may also be used in the field to verify correct channel functionality.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Test mode:
'0': Partial disconnect from IOSS. This mode's isolation allows for device test without relying on an external LIN transceiver. The IOSS 'tx' IO cell can be used to observe messages outside of the device.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].

'1': Full disconnect from IOSS (the IOSS/HSIOM should disconnect 'tx_out' from the 'tx' IO cell). This mode's isolation allows for device test without effecting an operational LIN cluster.
- tx_in[CH_IDX] = lin_tx_out[CH_IDX].
- tx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- rx_in[CH_IDX] = lin_tx_out[CH_IDX].
- rx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Test enable:
'0': Disabled. Functional mode.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_NR-1].
- rx_in[CH_IDX] = IOSS lin_rx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_rx_in[CH_NR-1].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX].
- lin_tx_out[CH_NR-1] = tx_out[CH_NR-1].
'1': Enabled. Test mode, specific test mode is specified by MODE.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>LIN channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL0</name>
            <description>Control 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400C0101</resetValue>
            <resetMask>0xF91F0313</resetMask>
            <fields>
              <field>
                <name>STOP_BITS</name>
                <description>STOP bit periods:
'0': 1/2 bit period.
'1': 1 bit period.
'2': 1 1/2 bit period.
'3': 2 bit periods.


In LIN mode, this field should be set to '1' (the default value) . 

In UART mode, this field can be programmed as desired.

Note: receiver STOP bit frame errors can only be detected if the number of STOP bit periods is 1 or more bit period.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_EN</name>
                <description>LIN transceiver auto enable:
'0': Disabled.
'1': Enabled. The TX_RX_STATUS.EN_OUT field is controlled by HW.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_DELIMITER_LENGTH</name>
                <description>In LIN mode, this field specifies the break delimiter length:
(used in header transmission, not used in header reception).
'0': 1 bit period.
'1': 2 bit periods (default value).
'2': 3 bit periods.
'3': 4 bit periods.

In UART mode, this field specifies the data field size:
'0': 5 bit data field.
'1': 6 bit data field.
'2': 7 bit data field.
'3': 8 bit data field.
When the data field size is less than 8 bits, the most significant (unused) bits of the DATAx.DATAy[7:0] fields should be set to '0' for the transmitter.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_WAKEUP_LENGTH</name>
                <description>Break/wakeup length (minus 1) in bit periods:
'0': 1 bit period.
...
'10': 11 bit periods (break length for slave nodes)
...
'12': 13 bit periods (break length for master nodes)
...
'30': 31 bit periods.
'31': Illegal (should NOT be used!!!)

This field is used for transmission/reception of BOTH break and wakeup signals. Note that these functions are mutually exclusive:
- When CMD.TX_HEADER is '1', the field specifies the transmitted break field.
- When CMD.TX_WAKEUP is '1', the field specifies the transmitted wakeup field.
- When CMD.RX_HEADER is '1', the field specifies the to be received break field.
- Otherwise, the field specifies the to be received wakeup field.

Per the standard, the master wakeup duration is between 250 us and 5 ms. To support uncalibrated slaves, a slave has a detection threshold of 150 us (3 bit periods at 20 kbps). After transmission of a break or wakeup signal, the INTR.TX_BREAK_WAKEUP_DONE interrupt cause is activated. After reception of a wakeup signal, the INTR.RX_BREAK_WAKEUP_DONE interrupt cause is activated.

To specify longer wakeup signals in terms of absolute time (us/ms rather than bit periods), the associated PERI clock divider value can be (temporarily) increased to make the LIN bit period longer.

Note: entering bus sleep mode is achieved with the 'go-to-sleep' command.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Mode of operation:
'0': LIN mode.
'1': UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>LIN</name>
                    <description>LIN mode.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>UART</name>
                    <description>UART mode.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIT_ERROR_IGNORE</name>
                <description>Specifies behavior on a detected bit error during header or response transmission:
'0': Message transfer is aborted.
'1': Message transfer is NOT aborted.

Note: this field does NOT effect the reporting of the bit error through INTR/STATUS.TX_HEADER/RESPONSE_BIT_ERROR; i.e. bit errors are always reported.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY</name>
                <description>Parity mode:
'0': Even parity: even number of '1' bits (including parity).
'1': Odd parity.

Note: Used in UART mode only.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY_EN</name>
                <description>Parity generation enable:
'0': Disabled. No parity bit is transferred.
'1': Enabled. The parity bit is transferred after the last (most significant) data field bit.

Note: Used in UART mode only.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>RX filter (for 'lin_rx_in'):
'0': No filter.
'1': Median 3 (default value) operates on the last three 'lin_rx_in' values. The sequences '000', '001', '010' and '100' result in a filtered value '0'. The sequences '111', '110', '101' and '011' result in a filtered value '1'.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. If a channel is disabled, all non-retained MMIO registers (e.g. the TX_RX_STATUS, and INTR registers) have their fields reset to their default value.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>Control 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3000000</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data fields (minus 1) in the response (not including the checksum):
'0': 1 data field.
'1': 2 data fields.
...
'7': 8 data fields.

Note: master and slave nodes need to agree upon the number of data fields before message transfer.
In RX_RESPONSE case, When PID (header) is received, firmware has the time of one response data byte, to modify CTL1.DATA_NR.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM_ENHANCED</name>
                <description>Checksum mode:
'0': Classic mode. PID field is NOT included in the checksum calculation.
'1': Enhanced mode. PID field is included in the checksum calculation. This mode requires special attention when the master node transmits the header and a (different) slave node transmits the response: the slave node will use the calculated partial checksum over the received PID field as a starting point for the calculation over the to be transmitted data fields.

Note: If the frame identifier ID[5:0] is 0x3c or 0x3d, the classic mode will ALWAYS be used for transmission and assumed for reception, independent of the CHECKSUM_ENHANCED value.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT</name>
                <description>Specifies the maximum allowed length (timeout value) for a frame, frame header or frame response in bit periods. The LIN specification prescribes to set the maximum length to 1.4x the nominal length (Theader_max = 1.4 x Theader_nom and Tresponse_max = 1.4 x Tresponse_nom). The nominal header length Theader_nom is 34 bit periods and the nominal response length Tresponse_nom is 10 * (data_nr + 1) bit periods (data_nr is the number of data fields) 

Note: the LIN specification specifies the following: 'Tools and tests shall check the Tframe_max (= Theader_max + Tresponse_max). Nodes shall not check this time. The receiving node of the frame shall accept the frame up to the next frame slot (i.e. next break field), even if it is longer then Tframe_max).'</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT_SEL</name>
                <description>Specifies the frame timeout mode:
'0': No timeout functionality (default value).
'1': Frame mode: detects timeout from the start of break field to checksum field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34+20 bit periods (header and a response with 1 data field).
'2': Frame header mode: detects timeout from the start of break field to PID field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34 bit periods (header).
'3': Frame response mode: detects timeout from the PID field STOP bits (exclusive) to checksum field STOP bits (the response space is included in the frame response). The minimum FRAME_TIMEOUT value is 20 bit periods (response with 1 data field).</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F03333F</resetMask>
            <fields>
              <field>
                <name>DATA_IDX</name>
                <description>Number of transferred data and checksum fields in the response (also acts as an index/address into response data field and checksum field registers (DATA0, DATA1, PID_CHECKSUM)) :
'0': No data fields transferred.
'1': Data field 1 transferred.
...
'7': Data fields 1, 2, 3, ... and 7 transferred.
'8':  Data fields 1, 2, 3, ... and 8 transferred.
'9': Data fields 1, 2, 3, ..., 8 and checksum field transferred.
'10'-'15': Unused.

Set to '0' on the start of a TX_HEADER or RX_HEADER command.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HEADER_RESPONSE</name>
                <description>Frame header / response identifier (only valid when TX_BUSY or RX_BUSY is '1'):
'0': Frame header being transferred.
'1': Frame response being transferred.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA0_FRAME_ERROR</name>
                <description>Frame response, first data field frame error. HW sets this field to '1'  when the received STOP bits of the first response data field have an unexpected value (only after a RX_HEADER command), and this data byte is 0x00. HW clears this field to '0' at the falling edge of SYNC start bit (after INTR.RX_HEADER_BREAK_WAKEUP_DONE). This field is used together with INTR.RX_RESPONSE_FRAME_ERROR to distinguish 'no response', 'error response' and 'correct response' scenarios.

Note: The ongoing message transfer is NOT aborted.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BUSY</name>
                <description>Transmitter busy.
- Set to '1' on the start of the following commands: TX_HEADER, TX_RESPONSE, TX_WAKEUP.
- Set to '0' on successful completion of previous commands or when an error is detected.
   In 'TX_HEADER, RX_RESPONSE' case, set to '0' at the start bit falling edge in the first response data byte, after header transmission</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BUSY</name>
                <description>Receiver busy.
- Set to '1' on the start of the following commands: RX_HEADER, RX_RESPONSE.
   in RX_HEADER case, set at Break filed rising edge.
   in RX_RESPONSE case, set at the start bit falling edge in the first response data byte.

- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DONE</name>
                <description>Transmitter done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- TX_HEADER.
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- TX_WAKEUP.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DONE</name>
                <description>Receiver done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- RX_HEADER, RX_RESPONSE.
- TX_HEADER, RX_RESPONSE.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Copy of INTR.TX_HEADER_BIT_ERROR.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Copy of INTR.TX_RESPONSE_BIT_ERROR.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Copy of INTR.RX_HEADER_FRAME_ERROR.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Copy of INTR.RX_HEADER_SYNC_ERROR.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Copy of INTR.RX_HEADER_PARITY_ERROR.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_FRAME_ERROR.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_CHECKSUM_ERROR.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD</name>
            <description>Command</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x307</resetMask>
            <fields>
              <field>
                <name>TX_HEADER</name>
                <description>SW sets this field to '1' to transmit a header. HW sets this field to '0' on successful completion of ANY of the following legal command sequences (also set to '0' when an error is detected):
- TX_HEADER
- TX_HEADER, TX_RESPONSE.
- TX_HEADER, RX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- RX_HEADER, RX_RESPONSE.
- TX_WAKEUP.

The header is transmitted when the PID field STOP bits are transmitted (INTR.TX_HEADER_DONE).

HW sets this field to '1', when the 'tr_cmd_tx_header' input trigger is activated. This allows for time triggered LIN message transfer. HW driven time triggered transfer eliminates the jitter that is typically associated with SW driven transfer.

In UART mode, a single data field (DATA0.DATA1) is transmitted.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE</name>
                <description>SW sets this field to '1' to transmit a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The response is transmitted when the checksum field STOP bits are transmitted (INTR.TX_RESPONSE_DONE).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP</name>
                <description>SW sets this field to '1' to transmit a wakeup signal. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The command generates CTL.BREAK_WAKEUP_LENGTH bit periods in the dominant state (low/'0') and transitions to the recessive state (high/'1') (INTR.TX_WAKEUP_DONE).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER</name>
                <description>SW sets this field to '1' to receive a header. HW sets this field to '0' on successful completion of the ANY of the legal command sequences (NOT set to '0' when an error is detected in LIN mode).

The header is received when the PID field STOP bits are received (INTR.RX_HEADER_DONE).

Typically, a slave node SW sets both RX_HEADER and RX_RESPONSE to '1', anticipating a transfer of a response from the master node to this slave node. After receipt of the header PID field (INTR.RX_HEADER_PID_DONE is activated), the slave node may decide to set TX_RESPONSE to '1' (which has a higher priority than RX_RESPONSE) to transmit a response.

the Break detection is performed regardless of CMD.RX_HEADER.
INTR.RX_BREAK_WAKEUP_DONE will trigger at LIN_RX rising edge, when the low pulse meet CTL0.BREAK_WAKEUP_LENGTH. when Break is detected, HW check CMD.RX_HEADER before entering SYNC byte processing state. when RX_HEADER is cleared, SW has at least 11 bit times to set RX_HEADER again, before next Break is detected (RX_BREAK_WAKEUP_DONE). in this case, there is no gap, Break will never be missed.


In UART mode, a single data field in received (in DATA0.DATA1). HW set this field to '0' when the data field is received, or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE</name>
                <description>SW sets this field to '1' to receive a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (NOT set to '0' when an error is detected).

The response is received when the checksum field STOP bits are received (INTR.RX_RESPONSE_DONE).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_STATUS</name>
            <description>TX/RX status</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000000</resetValue>
            <resetMask>0x5000000</resetMask>
            <fields>
              <field>
                <name>SYNC_COUNTER</name>
                <description>Synchronization counter in LIN channel clock periods. After the receipt of a synchronization field, this fields reflects the duration of the synchronization field. Ideally, SYNC_COUNTER = 8*16 = 128 (the synchronization fields consists of eight bit period of 16 LIN channel clock periods each).
- If SYNC_COUNTER is less than 128, the LIN channel clock is too slow and the PERI/PCLK divider value should be decreased.
- If SYNC_COUNTER is greater than 128, the LIN channel clock is too fast and the PERI/PCLK divider value should be increased.

The biggest master-slave clock discrepancy occurs when the master is slow and the slave is fast or vice versa. At a 0.5 percent master inaccuracy and a 14 percent slave inaccuracy, this results in the extreme synchronization values of (.86 * 128) / 1.005 = 109.5 and (1.14 *128) / 0.995 = 146.6. We add a little margin for a valid range of [106, 152].

Note: Only slave nodes with imprecise clocks require clock resynchronization. Master and slave nodes with precise clocks do NOT require clock resynchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_IN</name>
                <description>LIN transmitter input ('tx_in', 'lin_tx_in' in functional mode). TX_IN and RX_IN can be used to determine a wakeup source. Note that wakeup source detection relies on the external transceiver functionality.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_IN</name>
                <description>LIN receiver input ('rx_in', 'lin_rx_in' in functional mode).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OUT</name>
                <description>LIN transmitter output ('tx_out', 'lin_tx_out').</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EN_OUT</name>
                <description>LIN transceiver enable ('en_out', 'lin_en_out'). This field controls the enable (or low active sleep enable) of the external transceiver:
'0': Disabled.
'1': Enabled.

If CTL.AUTO_EN is '0', SW controls this field to enable the external transceiver. If CTL.AUTO_EN is '1', HW controls this field to enable the external transceiver:
- Before a legal command sequence, HW sets this field to '1', if it is '0'. The start of the command sequence is effectively postponed by a 4-bit period preamble.
- After a legal command sequence, HW clears this field to '0'. The end of the command sequence is effectively postponed by a 4-bit period postamble.

Note: external transceivers require a 'power up' or 'power down' period of 1 or 2 bit periods, so a 4-bit period suffices for all known transceivers.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PID_CHECKSUM</name>
            <description>PID and checksum</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 5 down to 0: frame identifier ID[5:0].
Frame identifier 0x3c is for a 'master request' frame, 0x3d is for a 'slave response' frame, 0x3e and 0x3f are for future LIN enhancements. Frame identifier ID[5:4] is optionally used for length control; i.e. specifies the number of response data fields.
- Bits 1 down to 0: parity bits P[1] and P[0].
  - P[1] = ! (ID[5] ^ ID[4] ^ ID[3] ^ ID[1])
  - P[0] = (ID[4] ^ ID[2] ^ ID[1] ^ ID[0])

Transmission: To be transmitted PID field. SW needs to calculate the PID field parity bits P[1] and P[0].

Reception: Received PID field. Slave node SW uses the PID field to determine how to handle the response for a received frame header: TX_RESPONSE or  RX_RESPONSE.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM</name>
                <description>Checksum.

Transmission: HW calculated checksum (SW does not need to calculate the checksum) over the transmitted PID field (optional per CTL.CHECKSUM_ENHANCED) and data fields.

Reception: Received checksum. Note that in case of a RX_CHECKSUM_ERROR, SW can use the received PID field and the  received data fields to calculate the correct checksum value.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>Response data 0</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA1</name>
                <description>Data field 1. 

Transmission: To be transmitted data field. SW provides data field.

Reception: Received data field. SW uses the data field.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Data field 2.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Data field 3.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Data field 4.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>Response data 1</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA5</name>
                <description>Data field 5.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Data field 6.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Data field 7.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA8</name>
                <description>Data field 8.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is transmitted (the CMD.TX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is transmitted (the CMD.TX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a wakeup signal is transmitted (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is received (the CMD.RX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is received (the CMD.RX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: activation implies that RX_RESPONSE_FRAME_ERROR and RX_RESPONSE_CHECKSUM_ERROR are not activated during response reception</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a break or wakeup signal is received (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.

The break or wakeup detection is always enabled, regardless of CMD register setting.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>HW sets this field to '1', when a synchronization field is received (including trailing STOP bits).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>HW sets this field to '1', when isolated '0' or '1' 'in_rx_in' values are observed or when during sampling the last three 'lin_rx_in' values do NOT all have the same value. This mismatch is an indication of noise on the LIN line.

Note: The ongoing frame transfer is NOT aborted.

Note: Used in UART mode.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>HW sets this field to '1', when a frame, frame header or frame response timeout is detected (per CTL.FRAME_TIMEOUT_SEL).

Note: The ongoing frame transfer is NOT aborted.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during header transmission). This specific test allows for delay through the external transceiver. This mismatch is an indication of bus collisions on the LIN line.

The match is performed for the Wakeup, Break, SYNC and the PID fields (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during response transmission).

The match is performed for the data fields and the checksum field (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during header reception).

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>HW sets this field to '1', when the received synchronization field is not received within the synchronization counter range [106, 152] (see TX_RX_STATUS.SYNC_COUNTER). 

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_SYNC_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>HW sets this field to '1', when the received PID field has a parity error. 

Note: The ongoing message transfer is aborted (INTR.RX_PID_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

+G119 HW sets this field to '1', when the received data field has a parity error (when CTL0.PARITY_EN is '1').</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during response reception). HW does NOT use this field for the STOP bits of the first data field after a RX_HEADER command, if the received data byte is 0x00. (STATUS.RX_DATA0_FRAME_ERROR is used instead).

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>HW sets this field to '1', when the calculated checksum over the received PID and data fields is not the same as the received checksum. 

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40440000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>CH</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x32380609</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>Message RAM Access Failure
The flag is set, when the Rx Handler
- has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message.
- was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM
in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_TTCAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted
Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into a Rx Buffer</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>M_TTCAN reports correctable ECC fault to the generic fault structure, this bit always reads as 0.
Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_ttcan_aeim_berr[0]
generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_ttcan_aeim_berr[1]
generated by an optional external parity / ECC logic attached to the Message RAM. An uncorrected
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC != 0,7)</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC != 0,7)</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Line  (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Line</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Line</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Line</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Line</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Line</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Line</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Line</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Line</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFFFFFF</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF0A.F0AI.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF1A.F1AI.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.
This field is updated by the software writing to TXEFA.EFAI.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is refracted.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x80</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>Clock Stop Request for each TTCAN IP .
The m_ttcan_clkstop_req of each TTCAN IP is directly driven by these bits.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.

To meet S8 platform requirements, MRAM_OFF should be set to 0 prior to transitioning to Hibernate mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x404A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32768</dimIncrement>
          <name>GRP[%s]</name>
          <description>Group of counters</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <dim>7</dim>
            <dimIncrement>128</dimIncrement>
            <name>CNT[%s]</name>
            <description>Timer/Counter/PWM Counter Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Counter control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0</resetValue>
              <resetMask>0xC73737FF</resetMask>
              <fields>
                <field>
                  <name>AUTO_RELOAD_CC0</name>
                  <description>Specifies switching of the CC0 and buffered CC0 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 0 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_CC1</name>
                  <description>Specifies switching of the CC1 and buffered CC1 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 1 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_PERIOD</name>
                  <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM and PWM_DT modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.

In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to select the index / wrap-around capture function.
'0': Captures on index (reload) event. The counter value is copied to the PERIOD register on an index (reload) event.
'1': Captures when COUNTER equals 0 or 0xffff. The counter value is copied to the PERIOD register when COUNTER equals 0 or 0xffff.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_LINE_SEL</name>
                  <description>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values. This field has a function in PWM and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting up
'1': compare match 0 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting down
'1': compare match 0 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting up
'1': compare match 1 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting down
'1': compare match 1 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_IMM_KILL</name>
                  <description>Specifies whether the kill event immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals or with the next module clock ('active count' pre-scaled 'clk_counter').
'0': synchronous kill activation. Deactivates the 'dt_line_out' and 'dt_line_compl_out' signals with the next module clock ('active count' pre-scaled 'clk_counter').
'1': immediate kill activation. Immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_STOP_ON_KILL</name>
                  <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL</name>
                  <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_DISABLE_MODE</name>
                  <description>Specifies the behavior of the PWM outputs 'line_out' and 'line_compl_out' while the TCPWM counter is disabled (CTL.ENABLED='0') or stopped.

Note: The output signal of this selection can be further modified by the immediate kill logic and line_out polarity settings (CTRL.QUAD_ENCODING_MODE).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The behavior is the same is in previous mxtcpwm (version 1).

When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are NOT driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).
Note: This is realized by driving the TCPWM output 'line_out_en' to 0.

When the counter is stopped upon a stop event the PWM outputs are deactivated (to the polarity defined by CTL.QUAD_ENCODING_MODE).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RETAIN</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM outputs are retained (keep their previous levels). 
While the counter is disabled or stopped the PWM outputs can be changed via LINE_SEL (when parameter GRP_SMC_PRESENT = 1).</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>L</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '0' and the PWM output 'line_compl_out' is driven as a fixed '1'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '1' and the PWM output 'line_compl_out' is driven as a fixed '0'.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UP_DOWN_MODE</name>
                  <description>Determines counter direction.

In QUAD mode this field acts as QUAD_RANGE_MODE field selecting between different counter range, reload value and compare / capture behavior.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>COUNT_UP</name>
                      <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_DOWN</name>
                      <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN1</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN2</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ONE_SHOT</name>
                  <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QUAD_ENCODING_MODE</name>
                  <description>In QUAD mode this field selects the quadrature encoding mode (X1/X2/X4) or the Up / Down rotary counting mode.
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUAD_ENCODING_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUAD_ENCODING_MODE[1].</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>X1</name>
                      <description>X1 encoding (QUAD mode)
This encoding is identical with an up / down counting functionality of the following way: Rising edges of input phiA increment or decrement the counter depending on the state of input phiB (direction input).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X2</name>
                      <description>X2 encoding (QUAD mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X4</name>
                      <description>X4 encoding (QUAD mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UP_DOWN</name>
                      <description>Up / Down rotary counting mode. Input phiA increments the counter, input phiB decrements the counter. The trigger edge detection settings apply.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MODE</name>
                  <description>Counter mode.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TIMER</name>
                      <description>Timer mode</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CAPTURE</name>
                      <description>Capture mode</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUAD</name>
                      <description>Quadrature mode

Different encoding modes can be selected by QUAD_ENCODING_MODE including up/down count functionality.
Different counter range, reload value and capture behavior can be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>Pulse width modulation (PWM) mode</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_DT</name>
                      <description>PWM with deadtime insertion mode</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_PR</name>
                      <description>Pseudo random pulse width modulation</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SR</name>
                      <description>Shift register mode.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DBG_FREEZE_EN</name>
                  <description>Specifies the counter behavior in debug mode.
'0': The counter operation continues in debug mode.
'1': The counter operation freezes in debug mode.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Counter enable.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_IN_SEL, TR_IN_EDGE_SEL, TR_PWM_CTRL and TR_OUT_SEL register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_out0' and tr_out1').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STATUS</name>
              <description>Counter status register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF8FF1</resetMask>
              <fields>
                <field>
                  <name>DOWN</name>
                  <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE0</name>
                  <description>Indicates the actual level of the selected capture 0 trigger.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_COUNT</name>
                  <description>Indicates the actual level of the selected count trigger.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_RELOAD</name>
                  <description>Indicates the actual level of the selected reload trigger.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_STOP</name>
                  <description>Indicates the actual level of the selected stop trigger.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_START</name>
                  <description>Indicates the actual level of the selected start trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE1</name>
                  <description>Indicates the actual level of the selected capture 1 trigger.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_OUT</name>
                  <description>Indicates the actual level of the PWM line output signal.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_COMPL_OUT</name>
                  <description>Indicates the actual level of the complementary PWM line output signal.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RUNNING</name>
                  <description>When '0', the counter is NOT running. When '1', the counter is running. 

This field is used to indicate that the counter is running after a start/reload event and that the counter is stopped after a stop event.
When a running counter operation is paused in debug state (see CTRL.DBG_PAUSE) then the RUNNING bit is still '1'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_L</name>
                  <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion (8bit dead time counter or low byte of 16-bit dead time counter). 
In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_H</name>
                  <description>High byte of 16-bit dead time counter. In PWM_DT mode, this counter is used for dead time insertion.
In all other modes, this field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8bit wide and the only the field DT_CNT_L is used as dead time counter.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>COUNTER</name>
              <description>Counter count register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNTER</name>
                  <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0</name>
              <description>Counter compare/capture 0 register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0_BUFF</name>
              <description>Counter buffered compare/capture 0 register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1</name>
              <description>Counter compare/capture 1 register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1_BUFF</name>
              <description>Counter buffered compare/capture 1 register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC1 register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD</name>
              <description>Counter period register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD_BUFF</name>
              <description>Counter buffered period register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Additional buffer for counter PERIOD register.

In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit represents a tap of the shift register which can be feed back to the MSB via an XOR tree. 
Examples for GRP_CNT_WIDTH = 16: 
- Maximum length 16bit LFSR
  - polynomial x^16 + x^14 + x^13 + x^11 + 1
  - taps 0,2,3,5 -&gt; PERIOD = 0x002d
  - period is 2^16-1 = 65535 cycles
- Maximum length 8bit LFSR: 
  - polynomial x^8 + x^6 + x^5 + x^4 + 1
  - taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)
  - period is 2^8-1 = 255 cycles

In SR mode PERIOD_BUFF defines which tap of the shift register generates the PWM output signals. For a delay of n cycles (from capture event to PWM output) the bit CNT_WIDTH-n should be set to '1'. For a shift register function only one tap should be use, i.e. a one-hot value must be written to PERIOD_BUFF. If multiple bits in PERIOD_BUFF are set then the taps are XOR combined.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL</name>
              <description>Counter line selection register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_out'. Default setting is the PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_out polarity setting (CTRL.QUAD_ENCODING_MODE[0]).</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_compl_out'. Default setting is the inverted PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_compl_out polarity setting (CTRL.QUAD_ENCODING_MODE[1]).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_compl_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_compl_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL_BUFF</name>
              <description>Counter buffered line selection register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Buffer for LINE_SEL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Buffer for LINE_SEL.COMPL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_COMPL_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT</name>
              <description>Counter PWM dead time register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>In PWM_DT mode, this field is used to determine the low byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain. 
In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.

Note: This field determines the low byte of the 16-bit dead time before activating 'line_out' when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by this DT_LINE_OUT_L field is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>In PWM_DT mode, this field is used to determine the high byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>In PWM_DT mode, this field is used to determine the dead time before activating the complementary PWM line output signal 'line_compl_out': amount of dead time cycles in the counter clock domain. 
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Counter trigger command register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3D</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0</name>
                  <description>SW capture 0 trigger. When written with '1', a capture 0 trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.ENABLED, the field is immediately set to '0'.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>SW reload trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP</name>
                  <description>SW stop trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>SW start trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1</name>
                  <description>SW capture 1 trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL0</name>
              <description>Counter input trigger selection register 0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_SEL</name>
                  <description>Selects one of the up to 256 input triggers as a capture0 trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. If existing, the one-to-one trigger inputs 'tr_one_cnt_in' (different to each counter) are selected by setting 2 and above. The settings above are used for the general purpose trigger inputs 'tr_all_cnt_in' connected to all counters selected.
In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNT_SEL</name>
                  <description>Selects one of the 256 input triggers as a count trigger. 
In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.

Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the counter is externally triggered ( COUNT_SEL &gt; 1), an external trigger will be required for each TR_CMD to execute. For example, a write to TR_CMD.START will not start the counter until the trigger selected by COUNT_SEL asserts. The next trigger will increment the counter since the counter is now running. This goes for all TR_CMD fields.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_SEL</name>
                  <description>Selects one of the 256 input triggers as a reload trigger. 
In QUAD mode, this is the index or revolution pulse. In these modes, it will update the counter with 0x8000 (counter midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_SEL</name>
                  <description>Selects one of the 256 input triggers as a stop trigger. 
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL1</name>
              <description>Counter input trigger selection register 1</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>START_SEL</name>
                  <description>Selects one of the 256 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1_SEL</name>
                  <description>Selects one of the 256 input triggers as a capture 1 trigger.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_EDGE_SEL</name>
              <description>Counter input trigger edge selection register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFF</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_EDGE</name>
                  <description>A capture 0 event will copy the counter value into the CC0 register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COUNT_EDGE</name>
                  <description>A counter event will increase or decrease the counter by '1'.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RELOAD_EDGE</name>
                  <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STOP_EDGE</name>
                  <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>START_EDGE</name>
                  <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CAPTURE1_EDGE</name>
                  <description>A capture 1 event will copy the counter value into the CC1 register.</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_PWM_CTRL</name>
              <description>Counter trigger PWM control register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFF</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CC0_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 0 event (COUNTER equals CC0 register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC0 register should be set to '0'. For a 100 percent duty cycle, the counter CC0 register should be set to larger than the counter PERIOD register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERFLOW_MODE</name>
                  <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UNDERFLOW_MODE</name>
                  <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CC1_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 1 event (COUNTER equals CC1 register) on the 'line_out' output signals.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_OUT_SEL</name>
              <description>Counter output trigger selection register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT0</name>
                  <description>Selects one of the internal events to generate the output trigger 0. Default setting selects the terminal count event.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event (default selection)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OUT1</name>
                  <description>Selects one of the internal events to generate the output trigger 1. Default setting selects the compare match 0 event.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event (default selection)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Counter matches CC0 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Counter matches CC1 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXS40ADCMIC0</name>
      <description>ADC</description>
      <headerStructName>MXS40ADCMIC</headerStructName>
      <baseAddress>0x40520000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADCMIC_CTRL</name>
          <description>Control the operation of the ADCMIC block including clock generation,clock selection and pdm data latching</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10542</resetValue>
          <resetMask>0x9FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_DIV_RATIO</name>
              <description>Divide ratio to divide clk_hf to yield clk_adc to process pdm_data</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_DIV_RATIO</name>
              <description>Divide ratio to divide clk_hf to generate clk_pdm to receive pdm_data</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RESET</name>
              <description>Reset for the adc domain 
 1: Out of reset and synchronized to clk_adc 
 0: In reset</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_LATCH_NEG_EDGE</name>
              <description>Edge of clk_hf used to latch pdm_data 
 1: Latch on negative edge 
 0: Latch on positive edge</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_DATA</name>
              <description>pdm data synchronuzed to clkc_sys</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_GATE_EN</name>
              <description>Two bit clock gate control that enables the mxtk_clk_gate cells 
 Bit 0: Controls clk_hf clock gate 
 Bit 1: Controls the clk_adc_syn from the ADC block</description>
              <bitRange>[14:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_LATCH_DELAY</name>
              <description>Number of clk_hf cycles from edge of clk_pdm to latch the pdm_data 
 When pdm_latch_neg_edge is 0 valid values are 2 through 8 
 When pdm_latch_neg_edge is 1 valid values are 3 through 9</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKS_ACTIVE_ADC</name>
              <description>clk sel for clk_adc - one hot encoded 
 00000 : No clocks selected - clock is gated off 
 00001 : clk_adc from local clk_divder is selected 
 00010 : Inverted clk_adc from local clk_divder is selected 
 00100 : clk_adc received from adc is used  
 01000 : Inverted clk_adc received from adc is used 
 10000 : clk_pdm_int is used as clk_adc</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKS_ACTIVE_PDM</name>
              <description>clk sel for clk_pdm - one hot encoded but the lower 2 bits and the upper 2 bits are independent of each other
 0000 : No clocks selected - clock is gated off 
 XX01 : clk_pdm from local clk_divder is selected  for external clk_pdm 
 XX10 : Inverted clk_pdm from local clk_divder is selected  for external clk_pdm 
 01XX : clk_pdm from local clk_divder is selected  as internal clk_adc to process pdm_data 
 10XX : Inverted clk_pdm from local clk_divder is selected  as internal clk_adc to latch pdm_data</description>
              <bitRange>[28:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMIC_EN</name>
              <description>Enables the adcmic operation
 This bit controls the pdm data being latched to begin the adcmic operation.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_PAD_CTRL</name>
          <description>Control the pads in the ADCMIC block</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CLK_PDM_OE</name>
              <description>Output enable for pdm clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_FIFO_CTRL</name>
          <description>Controls the operation of the fifo</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xE00707</resetValue>
          <resetMask>0x80FFFF3F</resetMask>
          <fields>
            <field>
              <name>PGMBLE_FULL</name>
              <description>Number of programmable words to indicate distance to fifo_full and will trigger programmable full level (afifo_pgmble_full)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PGMBLE_EMPTY</name>
              <description>Number of programmable words to indicate distance to fifo_empty and will trigger programmable empty level (afifo_pgmble_empty)</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_RESET</name>
              <description>[0] : fifo write reset when 0 and when 1 its out of reset
 [1] : fifo_read reset when 0 and when 1 its out of reset</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_STATUS</name>
              <description>Indicates fifo status of the fifo that stores pcm data. The almost empty and almost full indicates there is 1 location before being full or empty and pgmble indiates the level is half the depth of the fifo that has a total depth of 64. 
 fifo_status[7] = afifo_empty              
 fifo_status[6] = afifo_almost_empty
 fifo_status[5] = afifo_pgmble_empty
 fifo_status[4] = afifo_underflow
 fifo_status[3] = afifo_full
 fifo_status[2] = afifo_almost_full
 fifo_status[1] = afifo_pgmble_full
 fifo_status[0] = afifo_overflow</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_WR_BYPASS</name>
              <description>This is a bit set for debug where the data written into the fifo comes from the lfsr register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_LFSR_CTRL</name>
          <description>Controls the operation of the LFSR</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80622EE0</resetValue>
          <resetMask>0xFFFFBFFF</resetMask>
          <fields>
            <field>
              <name>LFSR_EN</name>
              <description>Write a 1 to this bit to begin the lfsr operation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SET</name>
              <description>When this bit is 1 then the lfsr register resets to 32'hFFFFFFFF</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_MODE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_VALID_CNTR_LIMIT</name>
              <description>The valid pulse for the lfsr_data dictates validity on a cycle basis. By default there is a new pattern every 750(0x2EE) cycles</description>
              <bitRange>[13:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_CLR</name>
              <description>When this bit is 1 then the lfsr register resets to 32'h00000000</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_TAPS</name>
              <description>This field provides the tap points for the LFSR wuth lfsr_taps[15:8] corresponds to tap points [31:24] of the lfsr register while lfsr_taps[7:0] corresponds to tap points [7:0] of the lfsr register.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TRIGGER</name>
          <description>Register to control Trigger</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>TR_DC</name>
              <description>Trigger when timer fires for DC measurement</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_DATA</name>
              <description>Trigger when output fifo has valid data</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TRIGGER_CLR</name>
          <description>Register to clear Trigger</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>TR_DC</name>
              <description>Activate functionality:
0: No effect.
1: Bit is set to 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA</name>
              <description>Activate functionality:
0: No effect.
1: Bit is set to 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TRIGGER_SET</name>
          <description>Register to set Trigger</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>TR_DC</name>
              <description>Activate functionality:
0: No effect.
1: Bit is set to 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA</name>
              <description>Activate functionality:
0: No effect.
1: Bit is set to 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TRIGGER_MASK</name>
          <description>Register to mask Trigger</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>TR_DC</name>
              <description>Mask for corresponding field in ADCMIC_TRIGGER register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA</name>
              <description>Mask for corresponding field in ADCMIC_TRIGGER register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_INTR</name>
          <description>Register to cause Interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_DC</name>
              <description>HW sets this field to 1, when dc measurement is done.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERRUPT_DATA</name>
              <description>HW sets this field to 1, when fifo has valid data</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_INTR_SET</name>
          <description>Register to set Interrupt</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_DC</name>
              <description>Write this field with '1' to set corresponding ADCMIC_INTR field (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERRUPT_DATA</name>
              <description>Write this field with '1' to set corresponding ADCMIC_INTR field (a write of '0' has no effect).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_INTR_MASK</name>
          <description>Register to mask Interrupt</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_DC</name>
              <description>Mask for corresponding field in ADCMIC_INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERRUPT_DATA</name>
              <description>Mask for corresponding field in ADCMIC_INTR register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_INTR_MASKED</name>
          <description>Register to and intr_mask Intr to crreate the interrupt</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_DC</name>
              <description>Logical AND of corresponding ADCMIC_INTR and ADCMIC_INTR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTERRUPT_DATA</name>
              <description>Logical AND of corresponding ADCMIC_INTR and ADCMIC_INTR_MASK fields.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TRIG_INTRPT_TIMER_CTRL</name>
          <description>Controls the timer for the generation of triggers and interrupts for dc measurement in the block</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000960</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_LIMIT</name>
              <description>At 96Mhz this count will generate interrupt to indicate that 25us has lapsed and the ADC core digital voltage is valid.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_CLR</name>
              <description>When high clk_timer is cleared</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_INC</name>
              <description>Enable the timer to begin counting on every clk_sys cycle to timer_limit and then generate the interrupt. 
 1: Counts up every clk_sys cycle 
 0: Counts when cic is updated</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_TP</name>
          <description>Data used for DFT test for setting and observing test points</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>TEST_POINT_SET_DATA</name>
              <description>Bits to control tests points</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_POINT_OBSERVE_DATA</name>
              <description>Bits to observe tests points</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCMIC_DATA</name>
          <description>N/A</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_DATA</name>
              <description>Data from the FIFO which contains two pcm data samples of 16 bits with the first sample in the lower half and the next sample in the upper half</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CLK_CTRL</name>
          <description>Control the clocks in the ADC block</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x39</resetMask>
          <fields>
            <field>
              <name>ADC_SYN_CLK_PHASE</name>
              <description>Output synchronization clock phase control
 0: non-inverted clock phase 
 1: inverted clock phase</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_CLK_GATE_EN</name>
              <description>Clock gate control to enable the clock to ADC
 0: Clock is Disabled  
 1: Clock is Enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_DATA_OUT</name>
              <description>Two bit PDM data from ADC that is latched
 3-level ADC data outputs:
 11 High
 01 Mid
 00 Low</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_GPIO_CTRL</name>
          <description>GPIO control for ADC</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ADC_DCIN_MUX</name>
              <description>ADC DC input selection (32-to-1 MUX) but only the lower 8 GPIO's are enabled so the selection is limited to GPIO 0 through 7:
 01111 ADC reference ground (ADC_REFGND)
 01110 ADC BG REF (ADC_BGREF)
 01101 Core supply (VDDC)
 01100 Battery/IO supply (VBAT/VDDIO)
 01011 GPIO 27 
 01010 GPIO 26 
 01001 GPIO 25 
 01000 GPIO 24 
 00111 GPIO 23 
 00110 GPIO 22 
 00101 GPIO 21 
 00100 GPIO 20 
 00011 GPIO 19 
 00010 GPIO 18 
 00001 GPIO 17 
 00000 GPIO 16 
 11111 GPIO 15 
 11110 GPIO 14 
 11101 GPIO 13 
 11100 GPIO 12 
 11011 GPIO 11 
 11010 GPIO 10 
 11001 GPIO 9  
 11000 GPIO 8  
 10111 GPIO 7  
 10110 GPIO 6  
 10101 GPIO 5  
 10100 GPIO 4  
 10011 GPIO 3  
 10010 GPIO 2  
 10001 GPIO 1  
 10000 GPIO 0</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_PD_CTRL</name>
          <description>Control the  power down controls in the ADC block.</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>ADC_EN_VBAT</name>
              <description>ADC IP level enable control from avddBAT supply domain:
 0: power down all the blocks supplied by VBAT when the 
 core supply is not ready 
 1: ADC power up/down controlled by 1.2V power up/down signals 
 Enable control signal in 1.6V-3.6V avddBAT supply domain</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_PWRUP</name>
              <description>ADC IP level main power up/down control: 
 0: power down whole ADC IP (Default)
 1: power up</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_REF_PWRUP</name>
              <description>ADC BG &amp; REF power up/down:
 0: power down BG and REF (Default)
 1: power up</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_CORE_PWRUP</name>
              <description>ADC core power up/down:
 0: power down ADC Core (Default)
 1: power up</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_PWRUP</name>
              <description>ADC MIC (Audio) path power up/down control:
 0: power down MIC bias and PGA (Default)
 1: power up</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_CLAMP_EN</name>
              <description>MIC PGA clamping enable/disable:
 0: disable MIC PGA clamping (Default)
 1: enable MIC PGA clamping</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MICBIAS_PWRUP</name>
              <description>MIC bias power up/down:
 0: power down MIC Bias(Default)
 1: Power up</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_MODE</name>
              <description>MIC (Audio) input and DC measurement input selection:
 0 ADC in DC Measurement Mode;
 DC measurement path enabled;
 MIC path powered down
 1 ADC in Audio application Mode;
 MIC path enabled. DC input is gated</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_MIC_PDSLT</name>
              <description>MIC path power up/down control selection in DC measurement mode:
 0: Power down MIC Bias and PGA in DC measurement Mode
 1: MIC path power up/down controlled by its pwrdn signal</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDDQ</name>
              <description>Chip global power down control:
 0: power up (Default)
 1: power down</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_BG_REF_CTRL</name>
          <description>Control the Band Gap and Reference Voltages of the ADC</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>ADC_BG_PTAT_CTRL</name>
              <description>BG PTAT current adjustment:
 011  3.62 percent
 010  2.32 percent
 001  1.11 percent
 000  0.00 percent
 111 -1.11 percent
 110 -2.17 percent
 101 -3.19 percent
 100 -4.10 percent</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_BG_CTAT_CTRL</name>
              <description>BG CTAT current adjustment:
 011  3.02 percent
 010  1.92 percent
 001  0.92 percent
 000  0.00 percent
 111 -0.93 percent
 110 -1.82 percent
 101 -2.68 percent
 100 -3.51 percent</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_REF_CTRL</name>
              <description>ADC reference voltage programmability:
 [3:0] Vref(mV)
 0000 850.0
 0001 856.1
 0010 862.1
 0011 868.2
 0100 874.3
 0101 880.4
 0110 886.4
 0111 892.5
 1000 801.4
 1001 807.5
 1010 813.6
 1011 819.6
 1100 825.7
 1101 831.8
 1110 837.9
 1111 843.9</description>
              <bitRange>[9:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_SCF_CLKDIV</name>
              <description>Switch cap filter clock frequency selection:
 00: 50KHz (default)
 01: 25KHz
 10: 100KHz
 11: 1.6MHz</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_SCF_BYPASS</name>
              <description>BG REF switch cap filter bypass
 0: enable switch cap filter
 1: bypass switch cap filter</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_SCF_BYPASS_SEQ</name>
              <description>External power up sequence for BG SCF bypass</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_SCF_SEQ_SLT</name>
              <description>Internal/External BG SCF power up sequence selection:
 0: use internal power up sequence
 1: use external power up sequence</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_BIAS_CTRL</name>
              <description>Global bias current programmability
 10: 3.0uA
 11: 2.5uA
 00: 2.5uA
 01: 2.0uA</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CORE_CTRL</name>
          <description>Control the clocks in the ADC block</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ADC_DITH_CTRL</name>
              <description>Dither Sequence control
 00: No dither
 01: prbs15
 10: prbs23
 11: prbs31</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_SHUFF_EN</name>
              <description>Disable the shuffler:
 0: disabled
 1: enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RESET_EN</name>
              <description>Disable reset function in DC measurement:
 0: disabled
 1: enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_DCINPUT_RANGE</name>
              <description>ADC input range selection for DC measurement path:
 0: 0-3.6V
 1: 0-1.8V</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_CLK_DIV2</name>
              <description>ADC internal clock division:
 0: disable divide-by-2; ADC sampling clock at 12MHz
 1: enable divide-by-2; ADC sampling clock at 6MHz</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MIC_BIAS_PGA_CTRL</name>
          <description>Control the BIAS and PGA of ADC block</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIC_BIAS_REF_CTRL</name>
              <description>MIC bias reference voltage programmability:
 00: 75 percent of Audio Supply (default)
 10: 80 percent of Audio Supply
 01 / 11: 70 percent of Audio Supply</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_BIAS_CTRL</name>
              <description>MIC bias output voltage programmability:
 00: 1.12 X Reference Voltage (default)
 01: 1.14 X Reference voltage
 10: 1.17 X Reference voltage
 11: 1.10 X Reference voltage</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_REF_SLT</name>
              <description>MIC bias reference selection:
 0: supply as MIC bias reference. MIC bias output voltage
 scaled with supply voltage
 1: BG voltage as MIC bias reference to have constant MIC
 bias output voltage</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_SCF_CLK_CTRL</name>
              <description>MIC bias reference filter clock programmability:
 00: 50KHz (default)
 01: 25KHz
 10: 100KHz
 11: 1.6MHz</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_SCF_BYPASS</name>
              <description>MIC bias switch cap filter bypass
 0: enable switch cap filter
 1: bypass switch cap filter</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_SCF_BYPASS_SEQ</name>
              <description>External power up sequence for MIC bias SCF bypass</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_SCF_SEQ_SLT</name>
              <description>Internal/External MIC bias SCF power up sequence selection:
 0: use internal power up sequence
 1: use external power up sequence</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_BIAS_LZ</name>
              <description>MIC bias low/high output impedance control during power down mode:
 0: MIC bias output is HZ in power down mode (default)
 1: MIC bias output is LZ in power down mode</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_PGA_GAIN_CTRL</name>
              <description>MIC PGA gain control: 1dB steps
 000000 : 0  dB
 000001 : 1  dB
 000010 : 2  dB
 000011 : 3  dB
 000100 : 4  dB
 000101 : 5  dB
 000110 : 6  dB
 000111 : 7  dB
 001000 : 8  dB
 001001 : 9  dB
 001010 : 10 dB
 001011 : 11 dB
 001100 : 12 dB
 001101 : 13 dB
 001110 : 14 dB
 001111 : 15 dB
 010000 : 16 dB
 010001 : 17 dB
 010010 : 18 dB
 010011 : 19 dB
 010100 : 20 dB
 010101 : 21 dB
 010110 : 22 dB
 010111 : 23 dB
 011000 : 24 dB
 011001 : 25 dB
 011010 : 26 dB
 011011 : 27 dB
 011100 : 28 dB
 011101 : 29 dB
 011110 : 30 dB
 011111 : 31 dB
 100000 : 32 dB
 100001 : 33 dB
 100010 : 34 dB
 100011 : 35 dB
 100100 : 36 dB
 100101 : 37 dB
 100110 : 38 dB
 100111 : 39 dB
 101000 : 40 dB
 101001 : 41 dB
 101010 : 42 dB</description>
              <bitRange>[16:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_PGA_INCM_CTRL</name>
              <description>PGA input common mode control 01 : 0.45 * avdd 00 : 0.4 * avdd 10 : 0.35 * avdd</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_PGA_OUTCM_CTRL</name>
              <description>PGA output common mode control
 01 : 0.7
 00 : 0.6
 10 : 0.5</description>
              <bitRange>[20:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_PGA_CLAMPVREF_CTRL</name>
              <description>PGA clamp threshold voltage control
 01 : 0.92  V
 00 : 0.95  V
 10 : 0.975 V
 11 : 1     V</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_NEG_INPUT_SLT</name>
              <description>N/A</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SPARE</name>
          <description>Spare registers in the ADC block</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>ADC_SPARE</name>
              <description>Spare Bits
 adc_spare[7] External reset of ADC
 0: Disabled
 1: Enabled</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_CTRL</name>
          <description>Register to control AuxAdcDecim operation</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4300</resetValue>
          <resetMask>0xFF7D</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>When 1 enable the aux_adc block</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_BYPASS</name>
              <description>When 1 bypass df3 FIR completely else FIR is enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIQUAD_BYPASS</name>
              <description>When 1 bypass biquad completely else biquad is enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFMODE</name>
              <description>Mode of Operation 
 0 : DC mode, 480kHz, fast:   with DC convergence time of 10^-6 seconds 
 1 : DC mode, 480kHz, medium: with DC convergence time of 15^-6 seconds 
 2 : DC mode, 480kHz, slow:   with DC convergence time of 20^-6 seconds 
 3 : Audio mode, 16kHz, analog mic 
 4 : Audio mode, 16kHz, digital mic 
 5 : Audio mode, 8kHz, analog mic 
 6 : Audio mode, 8kHz, digital mic</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MPR0</name>
              <description>Mapping bits mpr0 that maps to ADC data 00 or PDM data 0</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MPR1</name>
              <description>Mapping bits mpr1 that maps to ADC data 01</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MPR2</name>
              <description>Mapping bits mpr2 that maps to ADC data 10</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MPR3</name>
              <description>Mapping bits mpr3 that maps to ADC data 11 or PDM data 1</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_CIC_CTRL</name>
          <description>Register to control CIC operation in AuxAdcDecim block</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CIC_GAIN</name>
              <description>CIC gain value that will be used only during override. This will be used only when AUXADC_OVERRIDE[22] is set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_OVERRIDE</name>
          <description>Register that holds the override values for AuxAdcDecim block</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFF</resetMask>
          <fields>
            <field>
              <name>OVERRIDE</name>
              <description>Override Values for Auxadc. When override[22] is set then the remaining buts will override the default values within the matlab model generated RTL code 
 Bit  22    When set the values below are used to configure the auxAdcDecim block otherwise it defaults to the default values within the matlab generated code
 The cic gain is picked from the AUXADC_CIC_CTRL register when this is set. In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 16'h68DC 
 dfmode 001     : 16'h8638 
 dfmode 010     : 16'h2CBD 
 dfmode 011     : 16'hD1B7 
 dfmode 100     : 16'h51EC 
 dfmode 101     : 16'h346E 
 dfmode default : 16'hA3D7 
 Bits 21:16 Sets up counters for various modes of operation - In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 6'b000100 
 dfmode 001     : 6'b000100 
 dfmode 010     : 6'b000100 
 dfmode 011     : 6'b000100 
 dfmode 100     : 6'b000100 
 dfmode 101     : 6'b001001 
 dfmode default : 6'b001001 
 Bits 15:13 Sets up counters for CIC integrator to sample input - is a constant 3'b100 in the matlab model and is used when pdm is not enabled 
 Bits 12:10 The gain in the CIC integrator. In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 3'b011 
 dfmode 001     : 3'b101 
 dfmode 010     : 3'b101 
 dfmode 011     : 3'b011 
 dfmode 100     : 3'b001 
 dfmode 101     : 3'b011 
 dfmode default : 3'b010 
 Bits 09    Used for enabling pdm mode. In the matlab model this is set to 1 if dfmode is 4 or 6 and is the select of a mux that selects the pulse to sample pdm data.  
 Bits 08    This bit when set bypasses the 3rd stage of the integration in CIC. In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 1'b1 
 dfmode 001     : 1'b0 
 dfmode 010     : 1'b0 
 dfmode 011     : 1'b1 
 dfmode 100     : 1'b1 
 dfmode 101     : 1'b1 
 dfmode default : 1'b1 
 Bits 07:06 The delay in the first stage of CIC differntiator. In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 2'b01 
 dfmode 001     : 2'b01 
 dfmode 010     : 2'b11 
 dfmode 011     : 2'b00 
 dfmode 100     : 2'b00 
 dfmode 101     : 2'b00 
 dfmode default : 2'b00 
 Bits 05:04 The delay in the second stage of CIC differntiator. In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 2'b00 
 dfmode 001     : 2'b01 
 dfmode 010     : 2'b10 
 dfmode 011     : 2'b00 
 dfmode 100     : 2'b00 
 dfmode 101     : 2'b00 
 dfmode default : 2'b00 
 Bits 03    The delay in the third stage of CIC differntiator. In the matlab model this is constant 0 irrespective of dfmode 
 Bits 02:0  Enables various filters in the design.
 If the value is &gt;=1 then df1 is enabled
 if &gt;=2 then df2 is enabled
 if &gt;=3 then df3 is enabled
 if &gt;=4 then biquad is enabled. 
 In the matlab model this is based on dfmode as follows: 
 dfmode 000     : 3'b000 
 dfmode 001     : 3'b000 
 dfmode 010     : 3'b000 
 dfmode 011     : 3'b100 
 dfmode 100     : 3'b100 
 dfmode 101     : 3'b100 
 dfmode default : 3'b100</description>
              <bitRange>[22:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_DF3_COEFF</name>
          <description>Register that controls the RAM operation for writing DF3 Coefficients into the RAM</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8000</resetValue>
          <resetMask>0xFFFF81F7</resetMask>
          <fields>
            <field>
              <name>DF3_COEFF_SEL</name>
              <description>Sel for selecting Coefficient of df3 from the ram during the filtering at this stage</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_COEFF_PGM_EN</name>
              <description>Enable this bit before the df3_coeff ram can be programmed</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_COEFF_WREN</name>
              <description>Write Enable for writing Coefficient of df3</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_COEFF_ADDR</name>
              <description>Address for writing Coefficient of df3</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_ACCESS_DONE</name>
              <description>Hardware sets this bit when the operation is done while software clears this bit to start operation</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DF3_COEFF_DATA</name>
              <description>Data for writing Coefficient of df3 during the write cycle and read data during the read cycle</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD0_COEFF_0</name>
          <description>Register holding the coefficients for BIQUAD0 operation.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x81B23F27</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ0_NUM1_COEFF</name>
              <description>Coefficient for biquad0_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ0_NUM2_COEFF</name>
              <description>Coefficient for biquad0_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD0_COEFF_1</name>
          <description>Register holding the coefficients for BIQUAD0 operation.</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3F27</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BQ0_NUM3_COEFF</name>
              <description>Coefficient for biquad0_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD0_COEFF_2</name>
          <description>Register holding the coefficients for BIQUAD0 operation.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3E5181B5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ0_DEN2_COEFF</name>
              <description>Coefficient for biquad0_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ0_DEN3_COEFF</name>
              <description>Coefficient for biquad0_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD1_COEFF_0</name>
          <description>Register holding the coefficients for BIQUAD1 operation.</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4CCF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ1_NUM1_COEFF</name>
              <description>Coefficient for biquad1_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ1_NUM2_COEFF</name>
              <description>Coefficient for biquad1_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD1_COEFF_1</name>
          <description>Register holding the coefficients for BIQUAD1 operation.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BQ1_NUM3_COEFF</name>
              <description>Coefficient for biquad1_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD1_COEFF_2</name>
          <description>Register holding the coefficients for BIQUAD1 operation.</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ1_DEN2_COEFF</name>
              <description>Coefficient for biquad1_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ1_DEN3_COEFF</name>
              <description>Coefficient for biquad1_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD2_COEFF_0</name>
          <description>Register holding the coefficients for BIQUAD2 operation.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ2_NUM1_COEFF</name>
              <description>Coefficient for biquad2_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ2_NUM2_COEFF</name>
              <description>Coefficient for biquad2_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD2_COEFF_1</name>
          <description>Register holding the coefficients for BIQUAD2 operation.</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BQ2_NUM3_COEFF</name>
              <description>Coefficient for biquad2_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD2_COEFF_2</name>
          <description>Register holding the coefficients for BIQUAD2 operation.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ2_DEN2_COEFF</name>
              <description>Coefficient for biquad2_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ2_DEN3_COEFF</name>
              <description>Coefficient for biquad2_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD3_COEFF_0</name>
          <description>Register holding the coefficients for BIQUAD3 operation.</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ3_NUM1_COEFF</name>
              <description>Coefficient for biquad3_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ3_NUM2_COEFF</name>
              <description>Coefficient for biquad3_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD3_COEFF_1</name>
          <description>Register holding the coefficients for BIQUAD3 operation.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BQ3_NUM3_COEFF</name>
              <description>'Coefficient for biquad3_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD3_COEFF_2</name>
          <description>Register holding the coefficients for BIQUAD3 operation.</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ3_DEN2_COEFF</name>
              <description>Coefficient for biquad3_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ3_DEN3_COEFF</name>
              <description>Coefficient for biquad3_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD4_COEFF_0</name>
          <description>Register holding the coefficients for BIQUAD4 operation.</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ4_NUM1_COEFF</name>
              <description>Coefficient for biquad4_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ4_NUM2_COEFF</name>
              <description>Coefficient for biquad4_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD4_COEFF_1</name>
          <description>Register holding the coefficients for BIQUAD4 operation.</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BQ4_NUM3_COEFF</name>
              <description>Coefficient for biquad4_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD4_COEFF_2</name>
          <description>Register holding the coefficients for BIQUAD4 operation.</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BQ4_DEN2_COEFF</name>
              <description>Coefficient for biquad4_num1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BQ4_DEN3_COEFF</name>
              <description>Coefficient for biquad4_num2</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_CIC_STATUS</name>
          <description>Status of the CIC in AuxAdcDecim block</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>CIC</name>
              <description>Computed cic value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LATCH_ON_TIMER</name>
              <description>Latches continously by default but when set to 1 it latches on timer</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_DF1_STATUS</name>
          <description>Status of the DF1 FIR Filter in AuxAdcDecim block</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DF1</name>
              <description>Computed df1 value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_DF2_STATUS</name>
          <description>Status of the DF2 FIR Filter in AuxAdcDecim block</description>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DF2</name>
              <description>Computed df2 value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_DF3_STATUS</name>
          <description>Status of the DF3 FIR Filter in AuxAdcDecim block</description>
          <addressOffset>0x25C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DF3</name>
              <description>Computed df3 value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUXADC_BIQUAD_STATUS</name>
          <description>Status of the BIQUAD IIR  Filter in AuxAdcDecim block</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BQ</name>
              <description>Computed bq value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40590000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300400F</resetValue>
          <resetMask>0x9303D70F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of up to 256 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_WIDTH</name>
              <description>Determines the number of bits per FIFO data element, depending on physical SRAM cell data width.
On M0S8/MXS40S platform, the SRAM data width is 16 bit, so WORD (2) is not supported.
On MXS40E platform, the SRAM data width is 32 bits.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>8-bit FIFO data elements. 
This mode provides the biggest amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>16-bit FIFO data elements. 
TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 15].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>32-bit FIFO data elements. 
This mode provides the smallest amount of FIFO entries, but TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH can be in a range of [0, 31].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EC_ACCESS</name>
              <description>used to enable I2CS_EC or SPIS_EC access to internal SRAM memory.
0: enable clock_scb_en, has no effect on ec_busy_pp
1: disable clock_scb_en, enable ec_busy_pp (grant I2CS_EC or SPIS_EC access)

Before going to deepsleep this field should be set to 1. 
when waking up from DeepSleep power mode, and PLL is locked (clk_scb is at expected frequency), this filed should be set to 0.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
Generally hen the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).

Specific to SPI master case,  when SCB is idle,  below registers can be changed without disabling SCB block,
      TX_CTRL
      TX_FIFO_CTRL
      RX_CTRL
      RX_FIFO_CTRL
      SPI_CTRL.SSEL,</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000010</resetValue>
          <resetMask>0x8F017F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: data frames are always separated by slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.

In SPI Motorola submode, all four CPOL/CPHA modes are valid.
in SPI NS submode, only CPOL=0 CPHA=0 mode is valid.
in SPI TI submode, only CPOL=0 CPHA=1 mode is valid.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured in master mode, or MOSI is captured in slave mode.

When '0', the default applies,
for Motorola as determined by CPOL and CPHA, 
for Texas Instruments on the falling edge of SCLK(CPOL is '0' and CPHA is '1'), 
for National Semiconductors on the rising edge of SCLK(CPOL is '0' and CPHA is '0'). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). 
for master, applicable to all Motorola, TI and National Semiconductors flavors, and CPOL/CPHA timing mdoes.
for slave, applicable to Motorola flavor only, and CPHA=0 timing modes only, and internally-clocked mode only.

Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Instruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_SETUP_DEL</name>
              <description>Indicates the SPI SELECT setup delay (between SELECT activation and SCLK clock edge to sample the first MOSI bit).
'0': 0.75 SPI clock cycles
'1': 1.75 SPI clock cycles
Only applies in SPI MOTOROLA submode and when SCLK_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_HOLD_DEL</name>
              <description>Indicates the SPI SELECT hold delay (between SPI clock edge to sample the last MOSI bit, and SELECT deactivation).
'0': 0.75 SPI clock cycles 
'1': 1.75 SPI clock cycles 
Only applies in SPI MOTOROLA submode and when SCLK_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_INTER_FRAME_DEL</name>
              <description>Indicates the SPI SELECT inter-dataframe delay (between SELECT deactivation and SELECT activation).
'0': 1.5 SPI clock cycles
'1': 2.5 SPI clock cycles
Only applies in SPI MOTOROLA submode and when SPI_CTRL.SSEL_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
The IP should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TX_CTRL</name>
          <description>SPI transmitter control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10030</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_IDLE_HIGH</name>
              <description>SPI master MOSI output level when SELECT output inactive,
0: retain the level of last data bit
1: change to high,
   (MOSI level is high, before the first data bit time, and after data bit time, defined SSEL/SCLK driving edge with CPOL/CPHA)</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_CTRL</name>
          <description>SPI receiver control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x130</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0x10F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_LEVEL</name>
              <description>0: low level pulse detection, like Break field in LIN protocol
1: high level pulse detection, like IFS field in CXPI protocol, or idle line state in UART</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is mainly used in master mode. In slave mode, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.

in slave mode, this field is used to define number of clk_scb cycles for tSU-DAT timing (from ACK/NACK/data ready, to SCL rising edge (released from I2C slave clock stretching))</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>for I2C master, the NACKed byte should be properly received. it write  the data byte, before ACK/NACK decision. 

When '1', 
if a received data element byte is written, and the receiver FIFO become full, the master send out NACK .  
if the reciever FIFO is full (the received data byte cannot be written), it stretch SCL(extend SCL low phase) until the receiver FIFO changes to not full, to write the last byte, then send out NACK.

When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000035</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2CS_IC_BUSY</name>
              <description>Indicates whether the internally clocked slave logic is being accessed by external I2C master. 
--set at ADDR_MATCH
--clear at START/RESET, STOP detection, or BUS_ERROR
This bit can be used by SW to determine whether I2CS_IC is busy before entering DeepSleep.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HS_MODE</name>
              <description>this is to indicate I2C Hs-mode transfer,
it is set, after 'Start, master-code, NACK'' pattern,
   for I2CM,    at SCL falling edge, (INTR_M.I2C_HS_ENTER triggers),
   for I2CS_IC, at SCL falling edge, (INTR_S.I2C_HS_ENTER triggers),
   for I2CS_EC, at SCL rising  edge, after 2-DFF synchronization delay, when CTRL.EC_AM =1, AND CTRL.EC_ACCESS =0, 
it is cleared when Stop pattern is detected,
   for I2CM,    INTR_M.I2C_HS_EXIT triggers,
   for I2CS_IC, INTR_S.I2C_HS_EXIT triggers,
   for I2CS_EC, there is no respective interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>for I2C master, the NACKed byte should be properly received. it write  the data byte, before ACK/NACK decision. 

When '1', attempt to transmit a negative acknowledgement (NACK).
if the reciever FIFO is full (the received data byte cannot be written), it stretch SCL(extend SCL low phase) until the receiver FIFO changes to not full, to write the last byte, then send out NACK. 

When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x107</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_TX_ONES_ON_EMPTY</name>
              <description>When '1', attempt to send ones when TX_FIFO is empty. 

Once hardware starts to send ones, it will continue send ones until NACK is received, regardless of TX_FIFO status (even if new data is written into TX_FIFO).

This bit is used to avoid stretching SCL, which is not expected for some master devices.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_STRETCH_HS</name>
              <description>When '1', attempt to stretch SCL at time t1, SCL falling edge after 'START, Master-code, NACK' pattern is detected. 

When I2C_CTRL.HS_ENABLED is set, it should be set; after wakeup from DeepSleep power mode, it should also be set.

When INTR_S.I2C_HS_ENTER triggers, firmware configure clk_scb to meet I2C Hs-mode timing requirements, then firmware can clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_CTRL</name>
          <description>I2C stretch control</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>STRETCH_THRESHOLD</name>
              <description>stretch threthold.
Typically it is the SCL turaound delay (including IO cell delay, SCL rise time, analog filter delay), in number of clk_scb cycles.

When STRETCH_COUNT is higher than this STRETCH_THRESHOLD, STRETCH_DETECTED will be set.

STRETCH_DETECTED should be less than 'HOVS-2', HOVS means I2C_CTRL.HIGH_PHASE_OVS, or I2C_CTRL_HS.HOVS_HS.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_STATUS</name>
          <description>I2C stretch status</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x13F</resetMask>
          <fields>
            <field>
              <name>STRETCH_COUNT</name>
              <description>stretch count.
Started when I2C device start to drive high phase on internal SCL output signal, stalled when it detected high level on SCL input signal.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCH_DETECTED</name>
              <description>stretch detected.
Set when I2C rising edge comes later than expected (suppressed by another master or slave), and STRETCH_COUNT is higher than STRETCH_THRESHOLD.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC_DETECTED</name>
              <description>synchronization detected.
Set when I2C falling edge comes in earler than expected (suppressed by another I2C master during synchronization).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCHING</name>
              <description>I2C SCL is stretched by this block (DUT),
for I2C master, this can happen when  TX FIFO is empty, or RX_FIFO is full, or ACK/NACK is not decided, or RESTART/STOP is not decided.
For I2C slave, this can heppend,  TX FIFO is empty, or RX_FIFO is full, or ACK/NACK is not decided.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL_HS</name>
          <description>I2C control for High-Speed mode</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x88</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>HOVS_HS</name>
              <description>Serial I2C interface high phase oversampling factor for I2C Hs-mode. HOVS_HS + 1 peripheral clock periods constitute the high phase of a bit period. 

Hardware switch from I2C_CTRL.HIGH_PHASE_OVS to this value automacitcally, at time t1; and switch back time tFS (when STOP  detected).

Firmware configure clk_scb frequency properly between t1 and tH.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOVS_HS</name>
              <description>Serial I2C interface low phase oversampling factor for I2C Hs-mode. LOVS_HS + 1 peripheral clock periods constitute the low phase of a bit period. 

Hardware switch from I2C_CTRL.LOW_PHASE_OVS to this value automacitcally, at time t1; and switch back time tFS (when STOP  detected).

Firmware configure clk_scb frequency properly between t1 and tH.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_ENABLED</name>
              <description>0': I2C Hs-mode is disabled,
'1': I2C Hs-mode is enabled,

when I2C Hs-mode is disabled and the IP is in I2C slave mode, hardware response to incoming Hs-mode transfers are undefined.

When I2C Hs-mode is disabled and the IP is in I2C master mode, firmware should not generate Hs-mode transfers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20107</resetValue>
          <resetMask>0x3011F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH. 
DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. 
This number does not include start, parity and stop bits. 
For UART mode, the valid range is [3, 8]. 
For SPI, the valid range is [3, 31]. 
For I2C the only valid value is 7.
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- UART mode, 'uart_tx' IO cell.
- SPI mode, 'spi_miso' IO cell.

this bit is not applicable to I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN_SCL</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.

'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

this bit is applicable to I2C SCL only.
I2C SDA always work in open-drain mode.

this is not applicable to M0S8, which does not need special control in SCB for open-drain drive mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x31F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH. 
DATA_WIDTH + 1 is the expected amount of bits in received data frame. 
This number does not include start, parity and stop bits. 
For UART mode, the valid range is [3, 8]. 
For SPI, the valid range is [3, 31]. 
For I2C the only valid value is 7. 
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR  (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.

The Firmware should clear the TX FIFO, to re-do this transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>entered I2C Hs-mode, at time t1, SCL falling edge after 'START, 8-bit master code (0000_1XXX), NACK' sequence.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>exited I2C Hs-mode, after STOP detection.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. 

The Firmware should clear the TX FIFO, to re-do this transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed  (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>I2C slave RESTART received. 
Set to '1', when REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed  (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. 

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>entered I2C Hs-mode, at time t1, SCL falling edge after 'START, 8-bit master code (0000_1XXX), NACK' sequence.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>exited I2C Hs-mode, after STOP detection.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.TRIGGER_LEVEL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.MEM_WIDTH: (FF_DATA_NR = EZ_DATA_NR/2)
MEM_WIDTH is '0': # entries != FF_DATA_NR.
MEM_WIDTH is '1': # entries != FF_DATA_NR/2.
MEM_WIDTH is '2': # entries != FF_DATA_NR/4.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO, and the last stop field is transmitted (both TX FIFO and transmit shifter register are empty). Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is useful when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by RX_FIFO_CTRL.TRIGGER_LEVEL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.MEM_WIDTH: (FF_DATA_NR = EZ_DATA_NR/2)
MEM_WIDTH is '0': # entries == FF_DATA_NR.
MEM_WIDTH is '1': # entries == FF_DATA_NR/2.
MEM_WIDTH is '2': # entries == FF_DATA_NR/4.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x405A0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x405B0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x40810000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>LOCK_CC312_REGION</name>
              <description>CC312 lock - when set  locks 8 bytes beyond the end of the PROT_MASTER defined space for read access.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x140001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x140001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_6</name>
          <description>Sequencer read control 6</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_7</name>
          <description>Sequencer read control 7</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x801D0001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x35000B</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x240001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x26001E</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x240001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x340001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_6</name>
          <description>Sequencer program control 6</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x350001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_7</name>
          <description>Sequencer program control 7</description>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOTROW</name>
          <description>Content of Boot Row latches at power-on-reset</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BOOT_ROW_DATA</name>
              <description>Contains the Boot Row data held by the Boot Row latches.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIF0</name>
      <description>Serial Memory Interface</description>
      <headerStructName>SMIF</headerStructName>
      <baseAddress>0x40890000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x503400</resetValue>
          <resetMask>0x83F77FF1</resetMask>
          <fields>
            <field>
              <name>XIP_MODE</name>
              <description>Mode of operation.

Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MMIO_MODE</name>
                  <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ARB_MODE</name>
                  <description>''1': Arbitration mode. Arbitrates XIP vs. MMIO accesses such that any ongoing, pending, or 'merged' transactions on XIP always take priority over any MMIO accesses to the device.  However, if an MMIO access is in process it cannot be interrupted until it completes (as defined by sending the 'last command' via TX_CMD_MMIO_FIFO_WR).  If MMIO accesses are not happening at all, though, then the XIP accesses endure no extra arbitration latency.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_TX_SEL</name>
              <description>Specifies device interface transmitter clock options.
'0': SDR. Memory interface clock 'spihb_clk_out' is divided (by 2) interface clock 'clk_if', memory interface data signals are driven by divided (by 2) interface clock 'clk_if' with different phase than 'spihb_clk_out'. 
Results in driving memory interface data signals at falling 'spihb_clk_out' edge.
'1': DDR. Memory interface clock 'spihb_clk_out' is divided (by 2) inverted interface clock 'clk_if_inv', memory interface data signals are driven with interface clock 'clk_if'. 
Results in driving memory interface data signals 90 degrees before rising and falling 'spihb_clk_out' edge.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_LINE_SEL</name>
              <description>Specifies the delay line used for RX data capturing with 
- output / feedback clock based capturing (when CLOCK_IF_RX_SEL = [0..3] and DELAY_TAP_ENABLED = 1)
- internal clock based capturing (when CLOCK_IF_RX_SEL = [4..5], INT_CLOCK_CAPTURE_PRESENT = 1 and DELAY_TAP_ENABLED = 1)
- RWDS based capturing (when CLOCK_IF_RX_SEL = [6..7])</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_TAP_ENABLED</name>
              <description>Delay Line Tap Enable.
'0': Disabled. The delay line tap selections specified in registers DELAY_TAP_SEL or INT_CLOCK_DELAY_TAP_SEL0/1 are not used. The read data is directly captured by the RX data FIFO capture clock as specified by CLOCK_IF_RX_SEL and INT_CLOCK_CAPTURE_CYCLE.
'1': Enabled. The delay line tap selections specified in registers DELAY_TAP_SEL or INT_CLOCK_DELAY_TAP_SEL0/1 are used.
If the output / feedback clock based capture scheme (CLOCK_IF_RX_SEL = [0..3]) or the RWDS based capture scheme (CLOCK_IF_RX_SEL = [6..7]) is selected then the register DELAY_TAP_SEL is used to select the capture clock. If the internal clock based capture scheme (CLOCK_IF_RX_SEL = [4..5] and INT_CLOCK_CAPTURE_PRESENT = 1) is selected then the registers INT_CLOCK_DELAY_TAP_SEL0/1 are used to select the capture clock per data bit line (read data is captured by the capture logic and afterwards transferred to the RX data FIFO).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLOCK_DL_ENABLED</name>
              <description>Data Learning Enable for internal RX clock based on Data Learning Pattern. Only applies when CLOCK_IF_RX_SEL = [4..5] for selecting the internal clock based capture scheme and when DELAY_TAP_ENABLED = 1.  Must be set to 0 otherwise.
'0': Disabled. The delay line tap selections specified in registers INT_CLOCK_DELAY_TAP_SEL0/1 are not modified by HW.
'1': Enabled. The delay linle tap selections specified in registers INT_CLOCK_DELAY_TAP_SEL0/1 are modified by HW based on the data learning pattern. From all capture clock delay line taps producing a match between the expected data learning pattern in register DLP and the captured data learning pattern from the memory device the middle one is selected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLOCK_CAPTURE_CYCLE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_IF_RX_SEL</name>
              <description>N/A</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESELECT_DELAY</name>
              <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
'0': 1 memory interface clock cycle.
'1': 2 memory interface clock cycles.
'2': 3 memory interface clock cycles.
'3': 4 memory interface clock cycles.
'4': 5 memory interface clock cycles.
'5': 6 memory interface clock cycles.
'6': 7 memory interface clock cycles.
'7': 8 memory interface clock cycles.

During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_SETUP_DELAY</name>
              <description>Specifies the duration between 'spi_select_out[]' becomes low/'0') to 1st 'spi_clk_out' edge:
'0': 0 memory interface clock cycles + min. duration (see below).
'1': 1 memory interface clock cycle   + min. duration (see below).
'2': 2 memory interface clock cycles + min. duration (see below).
'3': 3 memory interface clock cycles + min. duration (see below).

In addition to the number of cycles selected here there is a min. duration of:
- 1 memory interface clock cycle (= 2 clk_if cycle) for SDR timing (CLOCK_IF_TX_SEL = 0)
- 1/4 memory interface clock cycle (= 1/2 clk_if cycle) for DDR timing (CLOCK_IF_TX_SEL = 1)</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_HOLD_DELAY</name>
              <description>Specifies the duration between last 'spi_clk_out' edge to 'spi_select_out[]' becomes high/'1'):
'0': 0 memory interface clock cycles + min. duration (see below).
'1': 1 memory interface clock cycle   + min. duration (see below).
'2': 2 memory interface clock cycles + min. duration (see below).
'3': 3 memory interface clock cycles + min. duration (see below).

In addition to the number of cycles selected here there is a min. duration of:
- 1/2 memory interface clock cycle (= 1 clk_if cycles) for SDR timing (CLOCK_IF_TX_SEL = 0)
- 1/4 memory interface clock cycle (= 1/2 clk_if cycle) for DDR timing (CLOCK_IF_TX_SEL = 1)</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO.

This field is not used for test controller accesses.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BUS_ERROR</name>
                  <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STATES</name>
                  <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).  This can be particularly true if ARB_MODE=1 and an MMIO access must wait a potentially long time behind a XIP access.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_SEL</name>
              <description>Specifies the clock source for 'clk_if'.  Must be 0 (clk_hf) before entering DeepSleep; can be returned to 1 (clk_pll) afterwards.
'0': clk_hf is used to create clk_if
'1': clk_pll is used to create clk_if</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors and AXI error responses.
'1': Enabled.

Notes: 
- Before disabling or resetting the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.
- After CTL.ENABLED is set to 1 it takes up to 20 clk_if cycles until the memory interface registers are realeased from reset.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>AHB Cache, AXI interface, cryptography, XIP, device interface, MPC (if present) initialization, or any other key logic busy in the IP:
'0': not busy
'1': busy
When BUSY is '0', the IP can be safely disabled without:
- the potential loss of transient write data.
- the potential risk of aborting an inflight SPI device interface transfer.
- disrupting MPC (if present) initialization
When BUSY is '0', the mode of operation (ARB_MODE or MMIO_MODE) can be safely changed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_STATUS</name>
          <description>Transmitter command FIFO status</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX command FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_MMIO_FIFO_STATUS</name>
          <description>Transmitter command MMIO FIFO status</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX command MMIO FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_MMIO_FIFO_WR</name>
          <description>Transmitter command MMIO FIFO write</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA27</name>
              <description>N/A</description>
              <bitRange>[26:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_CTL</name>
          <description>Transmitter data MMIO FIFO control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER_LEVEL</name>
              <description>Determines when the TX data MMIO FIFO 'tr_tx_req' trigger is activated:
- Trigger is active when TX_DATA_MMIO FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_STATUS</name>
          <description>Transmitter data FIFO status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_STATUS</name>
          <description>Transmitter data MMIO FIFO status</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data MMIO FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_WR1</name>
          <description>Transmitter data MMIO FIFO write</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data MMIO FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_WR2</name>
          <description>Transmitter data MMIO FIFO write</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data MMIO FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data MMIO FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_WR4</name>
          <description>Transmitter data MMIO FIFO write</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data MMIO FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data MMIO FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>TX data (written to TX data MMIO FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>TX data (written to TX data MMIO FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_MMIO_FIFO_WR1ODD</name>
          <description>Transmitter data MMIO FIFO write</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data MMIO FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_CTL</name>
          <description>Receiver data MMIO FIFO control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER_LEVEL</name>
              <description>Determines when RX data FIFO 'tr_rx_req' trigger is activated:
- Trigger is active when RX_DATA_MMIO_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_STATUS</name>
          <description>Receiver data MMIO FIFO status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data MMIO FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_STATUS</name>
          <description>Receiver data FIFO status</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10F</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data FIFO. Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_SR_USED</name>
              <description>Data available in RX Shift Register, i.e. completely read from RX data FIFO.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD1</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD2</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD4</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>RX data (read from RX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>RX data (read from RX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD1_SILENT</name>
          <description>Receiver data MMIO FIFO silent read</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>SMIF_CRYPTO</name>
          <description>Cryptography registers (one set for each key)</description>
          <addressOffset>0x00000200</addressOffset>
          <register>
            <name>CRYPTO_CMD</name>
            <description>Cryptography command</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>START</name>
                <description>SW sets this field to '1' to start an AES-128 forward block cipher operation (on CRYPTO_INPUT0-3). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_OUTPUT0, ..., CRYPTO_OUTPUT3.

The operation takes roughly 13 clk_mem clock cycles.

This register is only applicable for MMIO accesses and only in MMIO_MODE.  XIP accesses are encrypted on-the-fly in ARB_MODE and thus do not use this register.  Because XIP has exclusive access to the crypto engine in ARB_MODE, MMIO encryption is not available in that mode.  As such if encryption is needed for MMIO accesses in ARB_MODE that encryption must be done by other means (i.e., chip level crypto).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_ADDR</name>
            <description>Cryptography base address</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF00</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Only applies to XIP accesses.

Specifies the base address of the memory region that will have cryptography applied on XIP accesses with a unique key. If this region overlaps with another key's region, the lower numbered key is used (i.e., crypto key 0 has the highest priority).  If the region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].

Note that in order for cryptogrpahy to be applied the DEVICE.CTL.CRYPTO_EN must be set to 1 as well for any devices that share this region.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_MASK</name>
            <description>Cryptography mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF00</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Only applies to XIP accesses.

Specifies the size of the memory region whose base address is determined by CRYPTO_ADDR. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in CRYPTO_ADDR.ADDR: Address A is in the cryptography region when (A[31:8] &amp; MASK[31:8]) == CRYPTO_ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_SUBREGION</name>
            <description>Cryptography subregion disable</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SUBREGION_DISABLE</name>
                <description>Only applies to XIP accesses.

The cryptography region for this key as determined by CRYPTO_ADDR and CRYPTO_MASK is further divided into 8 equal subregions.  e.g., if a 1 MB region is specified then the 8 subregions will be 128 KB.  If SUBREGION_DISABLE=0 then cryptography will be performed on that subregion (assuming any associated DEVICE.CTL.CRYPTO_EN=1).  Otherwise if SUBREGION_DISABLE=1 then cryptography is not applied.  Note that setting all SUBREGION_DISABLE bits to 1 will effectively disable this key.

The encryption decision and the associated key are locked in at the beginning of a memory access and will apply until the end of such atomic accesses. Therefore, it is the user's responsibility to ensure memory accesses do not span across (sub)regions that have different keys and/or cypto enabled/disabled differently across such (sub)regions.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_INPUT0</name>
            <description>Cryptography input 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INPUT_LSB</name>
                <description>Plaintext PT[3:0] = CRYPTO_INPUT0.INPUT_LSB.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INPUT_MSB</name>
                <description>Plaintext PT[31:4] = CRYPTO_INPUT0.INPUT_MSB.</description>
                <bitRange>[31:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_INPUT1</name>
            <description>Cryptography input 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>Plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_INPUT2</name>
            <description>Cryptography input 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>Plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_INPUT3</name>
            <description>Cryptography input 3</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>Plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_KEY0</name>
            <description>Cryptography key 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_KEY1</name>
            <description>Cryptography key 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_KEY2</name>
            <description>Cryptography key 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_KEY3</name>
            <description>Cryptography key 3</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_OUTPUT0</name>
            <description>Cryptography output 0</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_OUTPUT1</name>
            <description>Cryptography output 1</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_OUTPUT2</name>
            <description>Cryptography output 2</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRYPTO_OUTPUT3</name>
            <description>Cryptography output 3</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Activated when a TX data MMIO FIFO trigger 'tr_tx_req' is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Activated when a RX data MMIO FIFO trigger 'tr_rx_req' is activated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Activated on a XIP access, when:
- a write transfer is requested
and 
- Dual-Quad SPI mode (selected device's ADDR_CTL.DIV2 is '1') is selected or
- Octal SPI DDR mode (selected device's DATA_CTL.DDR_MODE = '1' and DATA_CTL.WIDTH = '3') or Hyperbus mode (selected device's ADDR_CTL.SIZE3 = '7') is selected without memory write byte masking (selected device's WR_DUMMY_CTL.RWDS_EN = '0')
and 
- the AHB-Lite / AXI bus transfer address is not a multiple of '2' or 
- the requested AHB-Lite / AXI bus transfer size is NOT a multiple of '2'.

Additionally, it is activated on a XIP access when the selected memory device does not support write byte masking (WR_DUMMY_CTL.RWDS_EN=0) and an AXI transfer occurs with not all of the AXI write strobes ('wstrb') enabled according to the transfer size ('assize'). 

Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. Write accesses are only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2. Octal SPI DDR mode or Hyperbus mode are 16-bit word based protocols, writing single bytes is only possible when write byte masking is supported (via RWDS). Read accesses are always possible by extending the transfer size and / or aligning the address as needed and discarding the non-relevant byte(s).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Activated on an AHB-Lite write transfer to the TX command MMIO FIFO (TX_CMD_MMIO_FIFO_WR) with not enough free entries available.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Activated on an AHB-Lite write transfer to the TX data MMIO FIFO (TX_DATA_MMIO_FIFO_WR1, TX_DATA_MMIO_FIFO_WR2, TX_DATA_MMIO_FIFO_WR4, TX_DATA_MMIO_FIFO_WR1ODD) with not enough free entries available.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Activated on an AHB-Lite read transfer from the RX data MMIO FIFO (RX_DATA_MMIO_FIFO_RD1, RX_DATA_MMIO_FIFO_RD2, RX_DATA_MMIO_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Data Learning Failed (no DLP match found on at least one of the input data lines when CTL.INT_CLOCK_DL_ENABLED = 1).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Data Learning Warning (for at least one input data line less then DLP.DL_WARNING_LEVEL delay line taps resulted in a correct DLP capturing when CTL.INT_CLOCK_DL_ENABLED = 1).  This interrupt will be suppressed, though, if DL_FAIL also occurs during the same DLP evaluation cycle.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>CRC Error. A read transfer data CRC check failed.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Functional Safety Status Error. A read transfer Functional Safety Status check failed (see definition in DEVICE_ver2.RD_CRC_CTL.STATUS_CHECK_MASK and DEVICE_ver2.RD_CRC_CTL.STATUS_CHECK_MASK_POL).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Distinguishes normal vs. MPC interrupt</description>
          <addressOffset>0x7D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>NORMAL</name>
              <description>Reflects the state of interrupt_normal (which is the OR of the elements in the normal INTR_MASKED)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MPC</name>
              <description>Reflects the state of interrupt_mpc (which is the OR of the elements in the MPC'S INTR_MASKED)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>128</dimIncrement>
          <name>DEVICE[%s]</name>
          <description>Device (only used for XIP acceses)</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF311</resetMask>
            <fields>
              <field>
                <name>WR_EN</name>
                <description>Write enable:
'0': write transfers are not allowed to this device. An attempt to write to this device results in an AHB-Lite bus error.
'1': write transfers are allowed to this device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRYPTO_EN</name>
                <description>Cryptography on read/write accesses:
'0': disabled.
'1': enabled.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SEL</name>
                <description>Specifies the connection of the IP's data lines (spi_data[0], ..., spi_data[7]) to the device's data lines (SI/IO0, SO/IO1, IO2, IO3, IO4, IO5, IO6, IO7):
'0': spi_data[0] = IO0, spi_data[1] = IO1, ..., spi_data[7] = IO7. This value is allowed for single, dual, quad, dual quad and octal SPI modes. This value must be used for the first device in dual quad SPI mode. This value must be used for octal SPI mode.
'1': spi_data[2] = IO0, spi_data[3] = IO1. This value is only allowed for single and dual SPI modes.
'2': spi_data[4] = IO0, spi_data[5] = IO1, ..., spi_data[7] = IO3. This value is only allowed for single, dual, quad and dual quad  SPI modes. In dual quad SPI mode, this value must be used for the second device. 
'3': spi_data[6] = IO0, spi_data[7] = IO1. This value is only allowed for single and dual SPI modes.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MERGE_TIMEOUT</name>
                <description>Continuous transfer merge timeout in clk_mem cycles. This limits the standby time of the memory interface, i.e. the time the memory device is selected but no data is transferred.
The counting of the merge timeout period is done in the XIP block using clk_mem cycles. It starts when the last TX or RX byte is transferred to or from the data FIFOs.
After this period the memory device is deselected. A later transfer, even from a continuous address, starts with the overhead phases (command, address, mode, dummy cycles).</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>_1_cycle</name>
                    <description>Timeout after 1 clk_mem cycle. 
That means transfers will only be merged if the continuous transfer request is already available when the previous transfer is finished.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_16_cycles</name>
                    <description>Timeout after 2^4 = 16 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means 80ns.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_256_cycles</name>
                    <description>Timeout after 2^8 = 256 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~1.3us.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_4096_cycles</name>
                    <description>Timeout after 2^12 = 4096 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~20us.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_65536_cycles</name>
                    <description>Timeout after 2^16 = 65536 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~330us.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD5</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD6</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD7</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MERGE_EN</name>
                <description>Continous transfer merge enable:
'0': Disabled. No merging of transfers is done. Longest possible memory transfer is 16 Byte.
'1': Enabled. Merging of continous transfers is done. This skips the overhead (command, address, mode, dummy cycles) for a continuous (linear sequential) transfer.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOTAL_TIMEOUT</name>
                <description>Total transfer timeout in clk_mem cycles.
The counting of the total timout period is done in the XIP block using clk_mem cycles. It starts when the first command of a new (not merged) transaction is transferred to the TX command FIFO causing the interface logic to select the memory.
After this period the memory device is deselected.

This feature is needed for RAM devices requiring refresh cycles. The value needs to be derived from the RAMs maximum transaction length time (tCMS) minus the time of transferring 2x16byte data block (data granularity of the XIP ports is 16byte, 1 16byte block transfer outstanding, another available for merging). If the result in negative, MERGE_EN must be set to '0'.

Example: RAM device tCMS = 4us, interface clock frequency = 100MHz: total transfer timeout is 4us - 2x16x10ns = 3680ns. 
With clk_mem frequency of 200MHz the TOTAL_TIMEOUT value is 3680/5 = 736.

Note: In the unlikely case that the total transfer timeout is used (usually for RAM devices) while the page boundary crossing latency generation is enabled via RD_BOUND_CTL.PRESENT (usually for FLASH devices) the additional time needs to taken into account.</description>
                <bitRange>[29:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOTAL_TIMEOUT_EN</name>
                <description>Total transfer timeout enable.
'0': Disabled. There is no limit for the total transfer time. The continuous transfer merge timeout for limiting the idle time of the memory interface still applies.
'1': Enabled. The maximum total transfer time is limited by field TOTAL_TIMEOUT.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Device enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR</name>
            <description>Device region base address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Specifies the base address of the device region. If the device region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

In dual quad SPI data transfer, the two devices should have the same ADDR and MASK register settings. The device control information (ADDR_CTL, RD_CMD_CTL, etc.) are provided by the MMIO control registers of the device with the lowest index.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK</name>
            <description>Device region mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Specifies the size of the device region. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in ADDR.ADDR: Address A is in the device when (A[31:8] &amp; MASK[31:8]) == ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.

Note: a transfer request that is not in any device region results in an AHB-Lite bus error.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR_CTL</name>
            <description>Address control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x107</resetMask>
            <fields>
              <field>
                <name>SIZE3</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV2</name>
                <description>Specifies if the AHB-Lite bus transfer address is divided by 2 or not:
'0': No divide by 2.
'1': Divide by 2.  

This functionality is used for read and write operation in XIP, dual quad SPI mode; i.e. this DIV2 must be set to '1' in dual quad SPI mode. 
If DIV2 is set to '1', the memory does not support write masking (WR_DUMMY_CTL.RWDS_EN = '0'), and in this configuration a write transfer is requested and the write transfer request address is NOT a multiple of 2 or the requested number of Bytes to be written is not a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DELAY_TAP_SEL</name>
            <description>RX Clock Delay Tap Select Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Delay line tap selection in output / feedback clock based capture scheme (CLOCK_IF_RX_SEL = [0..3]) and RWDS capture scheme (CLOCK_IF_RX_SEL = [6..7]). This is used to shift the strobe signal into the data eye.

Any 2 devices connected in a dual quad SPI arrangement must set this register equivalently.

Note: DELAY_TAP_SEL must not be changed while STATUS.BUSY=1.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_STATUS</name>
            <description>Read status</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FS_STATUS</name>
                <description>Provides the Functional Safety Status Register of the memory received with the last read transfer.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CMD_CTL</name>
            <description>Read command control</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Command high byte code.
This field specifies the most significant command byte, sent before the least significant command byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of data transfer:
'0': 1 bit/cycle (single data transfer).
'1': 2 bits/cycle (dual data transfer).
'2': 4 bits/cycle (quad data transfer).
'3': 8 bits/cycle (octal data transfer).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate:
'0': SDR mode
'1': DDR mode</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of command field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') either the HB protocol needs to be selected (by ADDR_CTL.SIZE3='7') or this field needs to be set to PRESENT2='2'.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_ADDR_CTL</name>
            <description>Read address control</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_MODE_CTL</name>
            <description>Read mode control</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.
Note: If a mode field is present (PRESENT='1') for octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') the CODE is sent twice.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Mode high byte code.
This field specifies the most significant mode byte, sent before the least significant mode byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of mode field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') this field needs to be set to PRESENT2='2' to generate a mode field (or to PRESENT2='0').</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DUMMY_CTL</name>
            <description>Read dummy control</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.

Note: this field specifies dummy cycles, not dummy Bytes!</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present
'2': present - Dummy cycles are doubled when RWDS refresh indicator is high during CA cycle. (HyperRAM variable latency mode)

Notes: 
- If CLOCK_IF_TX_SEL = '0' for transmitting command, address and mode fields in SDR mode (driving data between falling edges of spihb_clk_out) and the memory is driving read data in DDR mode (based on memory type and transmitted command), then there must be at least 1 latency / dummy cycle specified (RD_DUMMY_CTL.PRESENT2 &gt; 0') to prevent controller and memory driving data signals at the same time. 
The same is true for the theoretical (practically irrelevant case) of transmitting at least one of the command, address and mode fields in DDR mode but receiving data from the memory in SDR mode.

- When using the RWDS / DQS based capturing scheme (CTL.CLK_IF_RX_SEL=[6,7]), then there is a minimum number of latency / dummy cycles required (RD_DUMMY_CTL.PRESENT2 &gt; 0). For the Hyperbus protocol (DDR_CTL.SIZE3=7) at least 1 latency / dummy cycle has to be specified, for SPI with DQS capturing at least 2 latency / dummy cycles need to be selected (RD_DUMMY_CTL.SIZE5 &gt; 0, exception see following note).

- In case of falling edge RWDS / DQS capturing (CTL.CLOCK_IF_RX_SEL = '6') and SDR mode, SW should reduce the number of dummy cycles by 1 compared to the latency cycles required by the memory device.

-DDR read commands need at least one dummy cycle

-For Hyperbus, set RD DUMMY_CTL.SIZE5=initial latency cycles-2</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA_CTL</name>
            <description>Read data control</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CRC_CTL</name>
            <description>Read Bus CRC control</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFF00</resetValue>
            <resetMask>0xDFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STATUS_CHECK_MASK</name>
                <description>Specifies which of the Functional Safety Status field bits are checked. There is 1 mask bit for each Functional Safety Status bit. 
'0': The associated Functional Safety Status bit is not checked.
'1': The associated Functional Safety Status bit is checked. If the received Funciontal Safety Status bit = Functional Safety Status Error Polarity (STATUS_ERROR_POLARITY), then a Functional Safety Status error interrupt and a XIP bus error response is generated.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATUS_ERROR_POL</name>
                <description>Specifies the polarity of the Functional Safety Status field bits. There is 1 polarity bit for each Functional Safety Status bit. 
'0': The associated Functional Safety Status bit is active-low.
'1': The associated Functional Safety Status bit is active-high.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_INPUT_SIZE</name>
                <description>Number of input data bytes for CRC generation (minus 1), i.e. number of data bytes over which the data CRC field is generated (minus 1):
'0': 1 byte
...
'255': 256 bytes.

Note: For octal data transfer with DDR mode (RD_DATA_CTL.WIDTH='3' and RD_DATA_CTL.DDR_MODE='1') the number of bytes for CRC generation must be even (i.e. DATA_CRC_INPUT_SIZE must be odd).</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_WIDTH</name>
                <description>Width of command / address CRC field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_DDR_MODE</name>
                <description>Mode of transfer rate of command / address CRC field.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_INPUT</name>
                <description>Specifies which fields are included in the command / address CRC generation.
'0': The command / address CRC field is generated over the address and (if present) mode fields only.
'1': The command / address CRC field is generated over the command, address and (if present) mode fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_CHECK</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_PRESENT</name>
                <description>Presence of command / address CRC field:
'0': not present
'1': present

Note: For octal data transfer with DDR mode (RD_CRC_CTL.WIDTH='3' and RD_CRC_CTL.DDR_MODE='1') the command / address CRC byte is sent twice, otherwise the command / address CRC byte is only sent once.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_PRESENT</name>
                <description>Presence of data CRC field:
'0': not present
'1': present

Note: Width and data transfer mode (SDR or DDR) of read data CRC fields are the same as for the associated read data fields, i.e. are specified by RD_DATA_CTL.WIDTH and RD_DATA_CTL.DDR_MODE.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_BOUND_CTL</name>
            <description>Read boundary control</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100000</resetValue>
            <resetMask>0x9033001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of base latency cycles (minus 1) used for calculating the number of fist page boundary crossing latency cycles:
'0': base_latency = 1 cycles
...
'31': base_latency = 32 cycles.

The actual latency cycles when crossing the first page boundary depend on the start address of the transaction and is calculated as follows:
if ((page_size - base_latency) &lt; Start_Addr &amp; (sub_page_size - 1))
  { ((Start_Addr &amp; (sub_page_size - 1)) - page_size + base_latency) }
else 
  { 0 }</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_PAGE_SIZE</name>
                <description>Specifies the size of a memory sub page 'sub_page_size'.
'0': sub_page_size = 8   words = 16 bytes (default).
'1': sub_page_size = 16 words = 32 bytes.
'2': sub_page_size = 32 words = 64 bytes.
'3': sub_page_size = 64 words = 128 bytes.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_PAGE_NR</name>
                <description>Specifies the number of sub pages per page.
'0': 1 sub pages per page, i.e. page_size = sub_page_size
'1': 2 sub pages per page, i.e. page_size = 2 x sub_page_size
'2': 4 sub pages per page, i.e. page_size = 4 x sub_page_size
'3': 8 sub pages per page, i.e. page_size = 8 x sub_page_size</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUBSEQ_BOUND_EN</name>
                <description>Enable subsequent page boundary latency cycles.
'0': Disabled. 
The page crossing latency cycles are only generated when crossing the first page boundary (i.e. the first time when the SUB_PAGE_NRth sub page boundary is crossed, e.g. with 2 sub pages per page when the 2nd sub page boundary is crossed).
'1': Enabled. 
The page crossing latency cycles are generated when crossing the first and subsequent page boundaries (i.e. every time when a SUB_PAGE_NRth sub page boundary is crossed, e.g. with 2 sub pages per page when the 2nd, 4th, 6th, ... sub page boundary is crossed).

Note: This only applies when the number of base latency cycles (SIZE5+1) is greater than the size of a page (base_latency &gt; page_size).  Must be set to 0 otherwise.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of first page boundary latency cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CMD_CTL</name>
            <description>Write command control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Command high byte code.
This field specifies the most significant command byte, sent before the least significant command byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of command field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') either the HB protocol needs to be selected (by ADDR_CTL.SIZE3='7') or this field needs to be set to PRESENT2='2'.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_ADDR_CTL</name>
            <description>Write address control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_MODE_CTL</name>
            <description>Write mode control</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Mode high byte code.
This field specifies the most significant mode byte, sent before the least significant mode byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of mode field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') this field needs to be set to PRESENT2='2' to generate a mode field (or to PRESENT2='0').</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DUMMY_CTL</name>
            <description>Write dummy control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC002001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWDS_EN</name>
                <description>Read-Write-Data-Strobe Enable. Specifies whether the RWDS output signal should be driven starting in the last dummy cycle until DESELECT. This is needed for write transactions with byte masking via RWDS (e.g. Hyperbus).
'0': do not drive RWDS output
'1': drive RWDS output starting in last dummy cycle until DESELECT

Note: this field is located in the WR_DUMMY_CTL register (and not in the WR_DATA_CTL register) since the RWDS signal needs to be driven already in the last dummy cycle.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present
'2': present - Dummy cycles are doubled when RWDS refresh indicator is high during CA cycle. (HyperRAM variable latency mode)</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DATA_CTL</name>
            <description>Write data control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CRC_CTL</name>
            <description>Write Bus CRC control</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCFFF0000</resetMask>
            <fields>
              <field>
                <name>DATA_CRC_INPUT_SIZE</name>
                <description>Number of input data bytes for CRC generation (minus 1), i.e. number of data bytes over which the data CRC field is generated (minus 1):
'0': 1 byte
...
'255': 256 bytes.

Note: For octal data transfer with DDR mode (WR_DATA_CTL.WIDTH='3' and WR_DATA_CTL.DDR_MODE='1') the number of bytes for CRC generation must be even (i.e. DATA_CRC_INPUT_SIZE must be odd).</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_WIDTH</name>
                <description>Width of command / address CRC field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_DDR_MODE</name>
                <description>Mode of transfer rate of command / address CRC field.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_INPUT</name>
                <description>Specifies which fields are included in the command / address CRC generation.
'0': The command / address CRC field is generated over the address and (if present) mode fields only.
'1': The command / address CRC field is generated over the command, address and (if present) mode fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_PRESENT</name>
                <description>Presence of command / address CRC field:
'0': not present
'1': present

Note: For octal data transfer with DDR mode (RD_CRC_CTL.WIDTH='3' and RD_CRC_CTL.DDR_MODE='1') the command / address CRC byte is sent twice, otherwise the command / address CRC byte is only sent once.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_PRESENT</name>
                <description>Presence of data CRC field:
'0': not present
'1': present

Note: Width and data transfer mode (SDR or DDR) of read data CRC fields are the same as for the associated read data fields, i.e. are specified by RD_DATA_CTL.WIDTH and RD_DATA_CTL.DDR_MODE.

Note: For octal data transfer with DDR mode (RD_DATA_CTL.WIDTH='3' and RD_DATA_CTL.DDR_MODE='1') the data CRC byte is sent twice, otherwise the data CRC byte is only sent once.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>HW sets this field to '1', when a security violation is detected. 
SW writes '1' to this field to clear</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>SW write this field with '1' to set INTR register (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VIOLATION</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO1</name>
            <description>Infor about violation</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Full address of the access that caused violation</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_INFO2</name>
            <description>Infor about violation</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF07FFFF</resetMask>
            <fields>
              <field>
                <name>HMASTER</name>
                <description>The master ID of the master that made the access causing the violation (taken from the AHB HMASTER signal)</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HNONSEC</name>
                <description>The security status of the access address causing the violation (taken from the AHB5 HNONSEC signal).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CFG_NS</name>
                <description>The secure/non-secure configuration of the block access attempt causing the violation.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HWRITE</name>
                <description>The R/W status from which the violating access was made.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HAUSER</name>
                <description>The protection context from which the violating access was made (taken from the AHB5 HAUSER signal).</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECURITY_VIOLATION</name>
                <description>This bit is set when a secure access was done to a non-secure block of memory, or a non-secure access was done to a secure block of memory.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACCESS_VIOLATION</name>
                <description>This bit is set when a read or write transaction was done from a protection context that does not have access to this block of memory.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CFG</name>
            <description>Sets block-size to match memory size (external memory only)</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1 MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for external memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.
HW initializes the block attributes NS to 1 in case SECEXT = 0.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TDM0</name>
      <description>TDM</description>
      <headerStructName>TDM</headerStructName>
      <baseAddress>0x408C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>TDM_STRUCT</name>
          <description>TDM structure</description>
          <addressOffset>0x00008000</addressOffset>
          <cluster>
            <name>TDM_TX_STRUCT</name>
            <description>TDM TX structure</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>TX_CTL</name>
              <description>TX control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x8001300F</resetMask>
              <fields>
                <field>
                  <name>WORD_SIZE</name>
                  <description>PCM word size:
'0': 8 bit.
'1': 10 bit.
'2': 12 bit.
'3': 14 bit.
'4': 16 bit.
'5': 18 bit.
'6': 20 bit.
'7': 24 bit.
'8': 32 bit.
'9'-'15': Undefined.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_8</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_10</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_12</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_14</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_16</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_18</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_20</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_24</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FORMAT</name>
                  <description>Format:
'0': Left-aligned delayed.
'1': Left-aligned.
'2': Right-aligned delayed.
'3': Right-aligned.</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>LEFT_DELAYED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LEFT</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT_DELAYED</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master/slave setting:
'0': Slave.
- External transmitter 'tdm_tx_sck_in' and transmitter 'tdm_tx_fsync_in'.
'1': Master.
- Interface clock 'clk_if' is used to generate transmitter 'tdm_tx_sck_out' and transmitter 'tdm_tx_fsync_out'.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SLAVE</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MASTER</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Transmitter (TX) enable:
'0': Disabled. All non-retained MMIO registers (e.g. the TX_FIFO_STATUS and INTR_TX registers) have their fields reset to their default value.
'1': Enabled.

Note: when all transmitters and receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register (or equivalent for platforms other than MXS40).</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_IF_CTL</name>
              <description>TX interface control</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F018707</resetValue>
              <resetMask>0x9F1FB7FF</resetMask>
              <fields>
                <field>
                  <name>CLOCK_DIV</name>
                  <description>Interface clock divider (legal range [1, 255]). The TDM interface 'tdm_tx_sck_out' output signal is defined as clk_if / (CLOCK_DIV + 1). CLOCK_DIV should be set to an odd value ({1, 3, 5, ..., 255}), to ensure a 50/50 percent duty cycle  clock.

Note: Used in master configuration only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLOCK_SEL</name>
                  <description>Interface clock 'clk_if' selection:
'0': SRSS clock clk_if_srss[0].
'1': SRSS clock clk_if_srss[1].
'2': SRSS clock clk_if_srss[2].
'3': SRSS clock clk_if_srss[3].
'4': Master interface clock 'tdm_tx_mck_in'.
'5'-'7': undefined.

Note: the application is always required to program this field to a value different from the default.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_TDM_TX_MCK_IN</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SCK_POLARITY</name>
                  <description>Clock polarity:
'0': Clock signal is used 'as is'.
'1': Clock signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_POLARITY</name>
                  <description>Channel synchronization polarity:
'0': Channel synchronization signal is used 'as is'.
'1': Channel synchronization signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_FORMAT</name>
                  <description>Channel synchronization pulse format:
'0': Duration of a single bit period.
'1': Duration of the first channel.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BIT_PERIOD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CH_PERIOD</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CH_NR</name>
                  <description>Number of channels in the frame:
'0': Undefined/illegal.
'1': 2 channels.
'2': 3 channels.
...
'31': 32 channels.

Note: the field value chould be less than CH_NR (the number of support channels).

Note: the TX_CH_CTL.CH_EN fields can be used to enable/disable indvidual channels.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_SIZE</name>
                  <description>Channel size:
'0'-'2': Undefined/illegal.
'3': 4 bits.
...
'31': 32 bits.

Note: if TX_CTL.WORD_SIZE is greater than CH_SIZE, the more significant bits of the word are transmitted and the lesser significant bits of the word are dropped.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_1</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_2</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>31</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>I2S_MODE</name>
                  <description>I2S mode setting:
'0': TDM mode.
'1': I2S mode.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TDM</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>I2S</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_CH_CTL</name>
              <description>TX channel control</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CH_EN</name>
                  <description>Channel enables: channel i is controlled by CH_EN[i].
'0': Disabled. The TX FIFO does not produce channel i words and the transmitted channel i words on the interface are not driven (the output enable of the 'tdm_tx_sd_out' output signal is not driven).
'1': Enabled.

Note: Only bit 0 through TX_IF_CTL.CH_NR may be set to '1'; i.e. only channels that are present in the frame can be enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_TEST_CTL</name>
              <description>TX test control</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Test mode enable.
'0': Disabled. Functional mode.
- Transmitter tx_sck_in = IOSS tdm_tx_sck_in.
- Transmitter tx_fsync_in = IOSS tdm_tx_fsync_in.
- Receiver rx_sd_in = IOSS tdm_rx_sd_in.
'1': Enabled. Test mode (intended to be used with (slave transmitter, master receiver) configuration).
- Transmitter tx_sck_in = Receiver tdm_rx_sck_out.
- Transmitter tx_fsync_in = Receiver tdm_rx_fsync_out.
- Receiver rx_sd_in = Transmitter tdm_tx_sd_out.

Note: TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1' simultaneously.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FUNCTIONAL</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TEST</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_ROUTE_CTL</name>
              <description>TX route control</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>MODE</name>
                  <description>Controls routing to the TX slave signalling inputs (FSYNC/SCK):
'0': TX slave signaling indipendent from RX signaling:
- Transmitter tx_sck_in = IOSS tdm_tx_sck_in
- Transmitter tx_fsync_in = IOSS tdm_tx_fsync_in
'1': TX slave signalling inputs driven by RX Slave:
- Transmitter tx_sck_in = IOSS tdm_rx_sck_in
- Transmitter tx_fsync_in = IOSS tdm_rx_fsync_in
'2': TX slave signalling inputs driven by RX Master:
- Transmitter tx_sck_in = receiver tdm_rx_sck_out
- Transmitter tx_fsync_in = receiver tdm_rx_fsync_out

Note: MODE=0 is the default behaviour. MODE=1 or 2 is intended to allow the TX slave to share the same signaling used by the RX. This feature can be used to reduce the number of IO pins necessary to connect to an external codec supporting common TX/RX signaling. 

Note: when MODE=1 or 2, TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1'.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_IOSS_TX_IN</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_IOSS_RX_IN</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_RX_OUT</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_CTL</name>
              <description>TX FIFO control</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF007F</resetMask>
              <fields>
                <field>
                  <name>TRIGGER_LEVEL</name>
                  <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated:
- INTR_TX.FIFO_TRIGGER = (# FIFO entries &lt; TRIGGER_LEVEL)</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUTE</name>
                  <description>Mute functionality:
'0': HW uses TX FIFO data.
'1': HW uses a constant PCM data value of '0'. Mute does advance the FIFO read pointer.

Note: HW ensures that mute functionality synchronizes on the first channel of a frame to ensure that either all or none of the frame's channels are muted.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FREEZE</name>
                  <description>Freeze functionality:
'0': HW uses TX FIFO data and advances the FIFO read pointer.
'1': HW uses a constant PCM data value of '0' or the previous channel PCM data is replayed. Freeze does not advance the FIFO read pointer (the FIFO data is not used).

Note: HW ensures that freeze functionality synchronizes on the first channel of a frame to ensure that PCM data of one channel is not misassigned to another channel. As a result, the freeze functionality can be activated at any time.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ACTIVE</name>
                  <description>Activate functionality:
'0': Transmitter off. The FIFO_UNDERFLOW interrupt cause will not be activated.
'1': Transmitter on. The FIFO_UNDERFLOW interrupt may be activated (when an underflow event occurs).

Note: This functionality is intended for startup purposes.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPLAY</name>
                  <description>Replay functionality (used when FREEZE is '1' or in case of a FIFO underflow event):
'0': HW uses a constant PCM data value of '0'.
'1': HW uses the previous PCM data value.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_STATUS</name>
              <description>TX FIFO status</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F00FF</resetMask>
              <fields>
                <field>
                  <name>USED</name>
                  <description>Number of used/occupied entries in the TX FIFO. The field value is in the range [0, 128]. When '0', the FIFO is empty. When '128', the FIFO is full.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RD_PTR</name>
                  <description>TX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WR_PTR</name>
                  <description>TX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_WR</name>
              <description>TX FIFO write</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Data (PCM sample) written to the TX FIFO. Writing adds the data to the TX FIFO; i.e. behavior is similar to that of a PUSH operation (TX_FIFO_STATUS.WR_PTR is incremented and TX_FIFO_STATUS.USED is incremented). The write data (DATA) should be right aligned when it is written to the FIFO entry (data[31:0]):
- 8 bit, data[31:0] = DATA[7:0] &lt;&lt; 24.
- 10 bit, data[31:0] = DATA[9:0] &lt;&lt; 22.
- 12 bit, data[31:0] = DATA[11:0] &lt;&lt; 20.
- 14 bit, data[31:0] = DATA[13:0] &lt;&lt; 18.
- 16 bit, data[31:0] = DATA[15:0] &lt;&lt; 16.
- 18 bit, data[31:0] = DATA[17:0] &lt;&lt; 14.
- 20 bit, data[31:0] = DATA[19:0] &lt;&lt; 12.
- 24 bit, data[31:0] = DATA[23:0] &lt;&lt; 8.
- 32 bit, data[31:0] = DATA[31:0].

Note: Writing to a full TX FIFO activates INTR.TX_FIFO_OVERFLOW.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX</name>
              <description>Interrupt</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>HW sets this field to '1', when a TX trigger is generated.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>HW sets this field to '1', when writing to a full TX FIFO (TX_FIFO_STATUS.USED is '128').</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>HW sets this field to '1', when reading from an (almost) empty TX FIFO (TX_FIFO_STATUS.USED &lt; 'number of enabled channels per frame'). This is referred to as an underflow event.

Note: HW ensures that either all or none of the frame's channels are transmitted. In a TX FIFO underflow situation, HW replays previous PCM data or uses a constant PCM data value of '0'.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>HW sets this field to '1', when PCM samples are not generated in time for the interface logic (interface underflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface underflow is a non-recoverable error and requires SW disabling of the channel (a SW write to INTR_TX.IF_UNDERFLOW does not resolve the interface underflow). 

Note: This functionality is intended for debug purposes.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_SET</name>
              <description>Interrupt set</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_MASK</name>
              <description>Interrupt mask</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_MASKED</name>
              <description>Interrupt masked</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>TDM_RX_STRUCT</name>
            <description>TDM RX structure</description>
            <addressOffset>0x00000100</addressOffset>
            <register>
              <name>RX_CTL</name>
              <description>RX control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x8001310F</resetMask>
              <fields>
                <field>
                  <name>WORD_SIZE</name>
                  <description>PCM word size:
'0': 8 bit.
'1': 10 bit.
'2': 12 bit.
'3': 14 bit.
'4': 16 bit.
'5': 18 bit.
'6': 20 bit.
'7': 24 bit.
'8': 32 bit.
'9'-'15': Undefined.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_8</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_10</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_12</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_14</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_16</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_18</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_20</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_24</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>WORD_SIGN_EXTEND</name>
                  <description>Word extension:
'0': zero extension.
'1': sign extension.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>ZERO_EXTEND</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIGN_EXTEND</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FORMAT</name>
                  <description>Format:
'0': Left-aligned delayed.
'1': Left-aligned.
'2': Right-aligned delayed.
'3': Right-aligned.</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>LEFT_DELAYED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LEFT</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT_DELAYED</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master/slave setting:
'0': Slave.
- External receiver 'tdm_rx_sck_in' and receiver 'tdm_rx_fsync_in'.
'1': Master.
- Interface clock 'clk_if' is used to generate receiver 'tdm_rx_sck_out' and receiver 'tdm_rx_fsync_out'.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SLAVE</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MASTER</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Receiver (RX) enable:
'0': Disabled. All non-retained MMIO registers (e.g. the RX_FIFO_STATUS and INTR_RX registers) have their fields reset to their default value.
'1': Enabled.

Note: when all transmitters and receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register (or equivalent for platforms other than MXS40).</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_IF_CTL</name>
              <description>RX interface control</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F018707</resetValue>
              <resetMask>0xFF1FF7FF</resetMask>
              <fields>
                <field>
                  <name>CLOCK_DIV</name>
                  <description>Interface clock divider (legal range [1, 255]). The TDM interface 'tdm_rx_sck_out' output signals is defined as clk_if / (CLOCK_DIV + 1). CLOCK_DIV should be set to an odd value ({1, 3, 5, ..., 255}), to ensure a 50/50 percent duty cycle  clock.

Note: Used in master configuration only.

Note: Due to delays in the IO SubSystem (specifically the IO cells), the maximum TDM interface clock 'tdm_rx_sck_out' may be restricted. As a result, the maximum bitrate is less than the theoretical maximum (32 channels, 32 bits per channel and a high Fs of e.g. 48 kHz). This restriction is most applicable to the master, receiver configuration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLOCK_SEL</name>
                  <description>Interface clock 'clk_if' selection:
'0': SRSS clock clk_if_srss[0].
'1': SRSS clock clk_if_srss[1].
'2': SRSS clock clk_if_srss[2].
'3': SRSS clock clk_if_srss[3].
'4': Master interface clock 'tdm_rx_mck_in'.
'5'-'7': undefined. 

Note: the application is always required to program this field to a value different from the default.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_TDM_RX_MCK_IN</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SCK_POLARITY</name>
                  <description>Clock polarity:
'0': Clock signal is used 'as is'.
'1': Clock signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_POLARITY</name>
                  <description>Channel synchronization polarity:
'0': Channel synchronization signal is used 'as is'.
'1': Channel synchronization signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LATE_SAMPLE</name>
                  <description>Interface late sample sample delay:
Slave configuration (RX_CTL.MS is '0').
'0': Sample PCM bit value on rising edge (SCK_POLARITY is '0') or falling edge (SCK_POLARITY is '1') of receiver 'rx_sck_in'.
'1': Sample PCM bit value on falling edge  (SCK_POLARITY is '0') or rising edge (SCK_POLARITY is '1') of receiver 'rx_sck_in' (half a cycle delay).

Master configuration (RX_CTL.MS is '1').
'0': Sample PCM bit value on rising edge (SCK_POLARITY is '0') or falling edge (SCK_POLARITY is '1') of receiver 'rx_sck_out'.
'1': Sample PCM bit value on falling edge  (SCK_POLARITY is '0') or rising edge (SCK_POLARITY is '1') of receiver 'rx_sck_out' (half a cycle delay).

Note: This field can be set to '1' when the roundtrip delay is large (typically) in a master receiver configuration.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FSYNC_FORMAT</name>
                  <description>Channel synchronization pulse format:
'0': Duration of a single bit period.
'1': Duration of the first channel.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BIT_PERIOD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CH_PERIOD</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CH_NR</name>
                  <description>Number of channels in the frame:
'0': Undefined/illegal.
'1': 2 channels.
'2': 3 channels.
...
'31': 32 channels.

Note: the field value chould be less than CH_NR (the number of support channels).

Note: the RX_CH_CTL.CH_EN fields can be used to enable/disable indvidual channels.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_SIZE</name>
                  <description>Channel size:
'0'-'2': Undefined/illegal.
'3': 4 bits.
...
'31': 32 bits.

Note: if RX_CTL.WORD_SIZE is greater than CH_SIZE, the lesser significant bits of the word are filled with '0's.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_1</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_2</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>31</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>LATE_CAPTURE</name>
                  <description>Extra delay (in 'rx_sck_out' cycles) for capturing 'tdm_rx_sd_in':
'0': no extra delay
'1': 1 cycle extra delay
'2': 2 cycles extra delay
'3': 3 cycles extra delay

Note: the value of this field pushes further out the capturing edges used by the receiver to sample 'tdm_rx_sd_in'. This function is intended to support very large round-trip delays in a master receiver configuration, where the delay at the receiver between 'tdm_rx_fsync_out' and the arrival of the first bit on 'tdm_rx_sd_in' is multiple clock cycles.</description>
                  <bitRange>[30:29]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>I2S_MODE</name>
                  <description>I2S mode setting:
'0': TDM mode.
'1': I2S mode.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TDM</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>I2S</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_CH_CTL</name>
              <description>RX channel control</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CH_EN</name>
                  <description>Channel enables: channel i is controlled by CH_EN[i].
'0': Disabled. The RX FIFO does not consume channel i words and the received channel i words on the interface are discarded.
'1': Enabled..

Note: Only bit 0 through RX_IF_CTL.CH_NR may be set to '1'; i.e. only channels that are present in the frame can be enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_TEST_CTL</name>
              <description>RX test control</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Test mode enable.
'0': Disabled. Functional mode.
- Receiver rx_sck_in = IOSS tdm_rx_sck_in.
- Receiver rx_fsync_in = IOSS tdm_rx_fsync_in.
- Receiver rx_sd_in = IOSS tdm_rx_sd_in.
'1': Enabled. Test mode (intended to be used with (master transmitter, slave receiver) configuration).
- Receiver rx_sck_in = Transmitter tdm_tx_sck_out.
- Receiver rx_fsync_in = Transmitter tdm_tx_fsync_out.
- Receiver rx_sd_in = Transmitter tdm_tx_sd_out.

Note: TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1' simultaneously.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FUNCTIONAL</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TEST</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_ROUTE_CTL</name>
              <description>RX route control</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>MODE</name>
                  <description>Controls routing to the RX slave signalling inputs (FSYNC/SCK):
'0': RX slave signaling indipendent from TX signaling:
- Receiver rx_sck_in = IOSS tdm_rx_sck_in
- Receiver rx_fsync_in = IOSS tdm_rx_fsync_in
'1': RX slave signalling inputs driven by TX Slave:
- Receiver rx_sck_in = IOSS tdm_tx_sck_in
- Receiver rx_fsync_in = IOSS tdm_tx_fsync_in
'2': RX slave signalling inputs driven by TX Master:
- Receiver rx_sck_in = transmitter tdm_tx_sck_out
- Receiver rx_fsync_in = transmitter tdm_tx_fsync_out

Note: MODE=0 is the default behaviour. MODE=1 or 2 is intended to allow the RX slave to share the same signaling used by the TX. This feature can be used to reduce the number of IO pins necessary to connect to an external codec supporting common TX/RX signaling. 

Note: when MODE=1 or 2, TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1'.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_IOSS_RX_IN</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_IOSS_TX_IN</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_TX_OUT</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_CTL</name>
              <description>RX FIFO control</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x6007F</resetMask>
              <fields>
                <field>
                  <name>TRIGGER_LEVEL</name>
                  <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated:
- INTR_RX.FIFO_TRIGGER = (# FIFO entries &gt; TRIGGER_LEVEL)</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FREEZE</name>
                  <description>Freeze functionality:
'0': HW writes to the RX FIFO and advances the FIFO write pointer.
'1': HW writes from the RX FIFO have no effect: freeze will not advance the FIFO write pointer.

Note: HW ensures that freeze functionality synchronizes on the first channel of a frame to ensure that PCM data of one channel is not misassigned to another channel. As a result, the freeze functionality can be activated at any time.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ACTIVE</name>
                  <description>Activate functionality:
'0': Receiver off. The FIFO_OVERFLOW interrupt cause will not be activated.
'1': Receiver on. The FIFO_OVERFLOW interrupt may be activated (when an overflow event occurs).

Note: This functionality is intended for stopping purposes.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_STATUS</name>
              <description>RX FIFO status</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F00FF</resetMask>
              <fields>
                <field>
                  <name>USED</name>
                  <description>Number of used/occupied entries in the RX FIFO. The field value is in the range [0, 128]. When '0', the FIFO is empty. When '128', the FIFO is full.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RD_PTR</name>
                  <description>RX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WR_PTR</name>
                  <description>RX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_RD</name>
              <description>RX FIFO read</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Data (PCM sample) read from the RX FIFO. Reading removes the data from the RX FIFO; i.e. behavior is similar to that of a POP operation (RX_FIFO_STATUS.RD_PTR is incremented and RX_FIFO_STATUS.USED is decremented). The read data (DATA) is right aligned (unused bit positions follow the specified sign extension per RX_CTL.WORD_SIGN_EXTEND) when it is read from the FIFO entry (data[31:0]):
- 8 bit, DATA[7:0] = data[31:24].
- 10 bit, DATA[9:0] = data[31:22].
- 12 bit, DATA[11:0] = data[31:20].
- 14 bit, DATA[13:0] = data[31:18].
- 16 bit, DATA[15:0] = data[31:16].
- 18 bit, DATA[17:0] = data[31:14].
- 20 bit, DATA[19:0] = data[31:12].
- 24 bit, DATA[23:0] = data[31:8].
- 32 bit, DATA[31:0] = data[31:0].

Note: Reading from an empty RX FIFO activates INTR_RX.FIFO_UNDERFLOW.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_RD_SILENT</name>
              <description>RX FIFO silent read</description>
              <addressOffset>0x8C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>N/A</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX</name>
              <description>Interrupt</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>HW sets this field to '1', when a RX trigger is generated.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>HW sets this field to '1', when writing to a (almost) full RX FIFO (128 -RX_FIFO_STATUS.USED &lt; 'number of enabled channels per frame'). This is referred to as an overflow event.

Note: HW ensures that either all or none of the frame's channels are received. In a RX FIFO overflow situation, HW discards received PCM data values.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>HW sets this field to '1', when reading from an empty RX FIFO (RX_FIFO_STATUS.USED is '0').</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>HW sets this field to '1', when PCM samples are generated too fast by the interface logic (interface overflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface overflow is a non-recoverable error and requires SW disabling of the channel (a SW write to INTR_RX.IF_OVERFLOW does not resolve the interface underflow).

Note: This functionality is intended for debug purposes.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_SET</name>
              <description>Interrupt set</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_MASK</name>
              <description>Interrupt mask</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_MASKED</name>
              <description>Interrupt masked</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM0</name>
      <description>PDM</description>
      <headerStructName>PDM</headerStructName>
      <baseAddress>0x408D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality (1 bit for each channel):
'0': Reception disabled. The FIFO_OVERFLOW interrupt cause will not be activated.
'1': Reception enabled. The FIFO_OVERFLOW interrupt may be activated (when an overflow event occurs).

Note: This functionality is intended for startup purposes. Typically, the startup sequence is as follows:
- global registers CLOCK_CTL, ROUTE_CTL, TEST_CTL, FIR*_COEFF* are initialized
- One or more structures are enabled (structure specific CTL.ENABLED register field is set to '1').
- The structures are initialized (structure specific MMIO registers are written).
- The structures are activated. This last step is performed by writing the CTL or CTL_SET MMIO registers, or on a rising edge ('0' to '1' transition) of a receiver's 'tr_activate' input trigger.

Note: on a rising edge ('0' to '1' transition) of a receiver's 'tr_activate' input trigger, its associated CTL.ACTIVE field is set to '1'. This allows HW based synchronization of PDM receiver activation based on system triggers. Implementation note: the trigger is synchronized on the receiver clock with the receiver reset (this requires the receiver to be enabled; i.e. CTL.ENABLED is '1').

Note: if CTL_CLR.ACTIVE[i] is written to '1' at the same time a rising edge of 'tr_activate[i]' occurs, CTL.ACTIVE[i] is set to '1' (i.e. trigger takes precedence).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTL_CLR</name>
          <description>Control clear</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality:
'0': No effect.
'1': Bit is set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTL_SET</name>
          <description>Control set</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality:
'0': No effect.
'1': Bit is set to '1'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x307</resetValue>
          <resetMask>0x103FF</resetMask>
          <fields>
            <field>
              <name>CLOCK_DIV</name>
              <description>PDM interface clock divider (legal range [3, 255]). The PDM interface clock clk_pdm ('pdm_clk[]' output signals) is defined as pdm_clk = clk_if / (CLOCK_DIV + 1); i.e. each PDM interface clock cycle equals CLOCK_DIV + 1 clk_if clock cycles. CLOCK_DIV should be set to an odd value ([3, 5, ..., 255]), to ensure a 50/50 percent duty cycle PDM interface clock pdm_clk.
'0-2': Illegal value.
'3': pdm_clk frequency is 1/4 clk_if frequency (1 pdm_clk cycle consists of 4 clk_if cycles).
'4': pdm_clk frequency is 1/5 clk_if frequency. Note: results in a non 50/50 percent duty cycle pdm_clk).
...
'255': pdm_clk frequency is 1/256 clk_if frequency.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Interface clock clk_if selection:
'0': SRSS clock clk_if_srss.
'1': IOSS data input signal 'pdm_data[0]'.
'2': IOSS data input signal 'pdm_data[1]'.
'3': undefined.

Note: when a data input signal is used as a clock source, it cannot be used as a data line.

Note: the application is always required to program this field to a value different from the default.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_SRSS_CLOCK</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PDM_DATA0</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PDM_DATA1</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_OR</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HALVE</name>
              <description>Halve rate sampling:
'0': Full rate sampling. The PDM interface clock pdm_clk is as specified by CLOCK_DIV[]. Each captured PDM value is provided once to the CIC filter.
'1': Halve rate sampling. The PDM interface clock clk_pdm is as specified by CLOCK_DIV[] divided by two (halve the frequency). Each PDM value is captured twice and provided twice to the CIC filter; i.e. the PDM value is repeated.

Note: this field is provided to dynamically change the digital microphone's clock (pdm_clk) without affecting the PDM sample frequency towards the CIC filter. Halving the microphone clock results in lower system power consumption, but does lower audio quality.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALVE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ROUTE_CTL</name>
          <description>Route control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_SEL</name>
              <description>Specifies what IOSS data input signal 'pdm_data[]' is routed to a specific PDM receiver. Each PDM receiver j has a dedicated 1-bit control field: PDM receiver j uses DATA_SEL[j]. The 1-bit field DATA_SEL[j] specification is as follows:
'0': PDM receiver j uses data input signal 'pdm_data[j]'.
'1': PDM receiver j uses data input signal 'pdm_data[j ^ 1]' (the lower bit of the index is inverted).

Routing the same data input signal to two PDM receivers allows for:
- A single stereo digital microphone.
- Two (mono) digital microphones that share a data line. 

E.g., if DATA_SEL is 0b00000010, PDM receivers 0 and 1 BOTH use 'pdm_data[0]'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F0400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRIVE_DELAY_HI</name>
              <description>Interface drive delay on the high phase of the PDM interface clock. This field specifies when a PDM value is driven expressed in clk_if clock cycles. DRIVE_DELAY should be set in the range [0, IF_CTL.CLOCK_DIV]:
'0': Drive PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Drive PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Drive PDM value 256 clk_if cycles after the rising edge of clk_pdm.

Note: To drive on the falling edge of the PDM interface clock clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV/2. To drive on the rising edge of clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVE_DELAY_LO</name>
              <description>Interface drive delay on the low phase of the PDM interface clock. This field specifies when a PDM value is driven expressed in clk_if clock cycles. DRIVE_DELAY should be set in the range [0, IF_CTL.CLOCK_DIV]:
'0': Drive PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Drive PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Drive PDM value 256 clk_if cycles after the rising edge of clk_pdm.

Note: To drive on the falling edge of the PDM interface clock clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV/2. To drive on the rising edge of clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_HI</name>
              <description>Pattern generator mode on the high phase of the PDM interface clock. This field specifies the type of PDM pattern driven by the generator:
'0': constant 0's
'1': constant 1's
'2': alternating 0's and 1's (clock pattern)
'3': sinusoid</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONSTANT_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CONSTANT_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTERNATING</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINUSOID</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_LO</name>
              <description>Pattern generator mode on the low phase of the PDM interface clock. This field specifies the type of pattern driven by the generator:
'0': constant 0's
'1': constant 1's
'2': alternating 0's and 1's (clock pattern)
'3': sine wave</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONSTANT_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CONSTANT_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTERNATING</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINUSOID</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUDIO_FREQ_DIV</name>
              <description>Frequency division factor (legal range [3, 13]) to obtain audio frequency from the PDM clock frequency. This field determines the frequency of the sine wave generated by the pattern generator when MODE=3. The formula is below:

Sine wave Frequency = PDM clock frequency / 2p*2^(AUDIO_FREQ_DIV)

Example: when PDM clock frequency = 3.072 MHz the audio frequencies obtained for the various values of AUDIO_FREQ_DIV are shown below:

'3' : 61.115 kHz
'4' : 30.558 kHz
'5' : 15.279 kHz
'6' : 7.639 kHz
'7' : 3.820 kHz
'8' : 1.910 kHz
'9' : 955 Hz
'10' : 477 Hz
'11' : 239 Hz
'12' : 119 Hz
'13' : 60 Hz</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_8</name>
                  <description>Example: 3.072 MHz/(2p*8) = 61.115 kHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_16</name>
                  <description>Example: 3.072 MHz/(2p*16) = 30.558 kHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_8192</name>
                  <description>Example: 3.072 MHz/(2p*8192) = 60 Hz</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_ENABLED</name>
              <description>Pattern generator enable (1 bit for each channel):
'0' : disabled, the channel input is taken as normal from external pin pdm_data_in
'1' : enabled, the channel input is taken from the pattern generator

Note: the pattern generator output is routed to pdm_data_out for testing purposes

Note: when all channels are disabled the pattern generator is switched off</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF0</name>
          <description>FIR 0 coefficients 0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 0 and 29 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 1 and 28 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF1</name>
          <description>FIR 0 coefficients 1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 2 and 27 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 3 and 26 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF2</name>
          <description>FIR 0 coefficients 2</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 4 and 25 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 5 and 24 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF3</name>
          <description>FIR 0 coefficients 3</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 6 and 23 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 7 and 22 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF4</name>
          <description>FIR 0 coefficients 4</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 8 and 21 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 9 and 20 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF5</name>
          <description>FIR 0 coefficients 5</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 10 and 19 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 11 and 18 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF6</name>
          <description>FIR 0 coefficients 6</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 12 and 17 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 13 and 16 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF7</name>
          <description>FIR 0 coefficients 7</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter tap 14 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter tap 15 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF0</name>
          <description>FIR 1 coefficients 0</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x153FFE</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 0 and 54 coefficient (default value -2).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 1 and 53 coefficient (default value 21).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF1</name>
          <description>FIR 1 coefficients 1</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FEF001A</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 2 and 52 coefficient (default value 26).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 3 and 51 coefficient (default value -17).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF2</name>
          <description>FIR 1 coefficients 2</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x193FD7</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 4 and 50 coefficient (default value -41).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 5 and 49 coefficient (default value 25).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF3</name>
          <description>FIR 1 coefficients 3</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FDF0044</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 6 and 48 coefficient (default value 68).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 7 and 47 coefficient (default value -33).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF4</name>
          <description>FIR 1 coefficients 4</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x293F95</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 8 and 46 coefficient (default value -107).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 9 and 45 coefficient (default value 41).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF5</name>
          <description>FIR 1 coefficients 5</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FD000A0</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 10 and 44 coefficient (default value 160).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 11 and 43 coefficient (default value -48).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF6</name>
          <description>FIR 1 coefficients 6</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x363F1A</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 12 and 42 coefficient (default value -230).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 13 and 41 coefficient (default value 54).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF7</name>
          <description>FIR 1 coefficients 7</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FC80145</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 14 and 40 coefficient (default value 325).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 15 and 39 coefficient (default value -56).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF8</name>
          <description>FIR 1 coefficients 8</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x333E3B</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 16 and 38 coefficient (default value -453).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 17 and 37 coefficient (default value 51).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF9</name>
          <description>FIR 1 coefficients 9</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FE10277</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 18 and 36 coefficient (default value 631).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 19 and 35 coefficient (default value -31).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF10</name>
          <description>FIR 1 coefficients 10</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FEB3C82</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 20 and 34 coefficient (default value -894).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 21 and 33 coefficient (default value -21).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF11</name>
          <description>FIR 1 coefficients 11</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xAC052E</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 22 and 32 coefficient (default value 1326).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 23 and 31 coefficient (default value 172).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF12</name>
          <description>FIR 1 coefficients 12</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3CFE3771</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 24 and 30 coefficient (default value -2191).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 25 and 29 coefficient (default value -770).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF13</name>
          <description>FIR 1 coefficients 13</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FFF12FB</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 26 and 28 coefficient (default value 4859).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 27 (center tap) coefficient (default value 8191).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>PDM RX structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x8000010F</resetMask>
            <fields>
              <field>
                <name>WORD_SIZE</name>
                <description>PCM word size:
'0': 8 bit.
'1': 10 bit.
'2': 12 bit.
'3': 14 bit.
'4': 16 bit.
'5': 18 bit.
'6': 20 bit.
'7': 24 bit.
'8': 32 bit.
'9'-'15': Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SIZE_8</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_10</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_12</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_14</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_16</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_18</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_20</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_24</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_32</name>
                    <description>N/A</description>
                    <value>8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WORD_SIGN_EXTEND</name>
                <description>Word extension:
'0': zero extension.
'1': sign extension.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ZERO_EXTEND</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIGN_EXTEND</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Receiver enable:
'0': Disabled. If a receiver is disabled, all non-retained MMIO registers (e.g. the RX_FIFO_STATUS and INTR_RX registers) have their fields reset to their default value.

'1': Enabled.

Note: when all receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register (or equivalent for platforms other than MXS40).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IF_CTL</name>
            <description>Interface control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SAMPLE_DELAY</name>
                <description>Interface sample delay. This field specifies when a PDM value is captured, expressed in clk_if clock cycles. 

When CLOCK_CTL.HALVE=0:
'0': Capture PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Capture PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Capture PDM value 256 clk_if cycles after the rising edge of clk_pdm.

When CLOCK_CTL.HALVE=1:
'0': Capture PDM value 1 and 2 clk_if cycles after the rising edge of clk_pdm.
'1': Capture PDM value 3 and 4 clk_if cycles after the rising edge of clk_pdm.
...
'255': Capture PDM value 511 and 512 clk_if cycles after the rising edge of clk_pdm.

SAMPLE_DELAY should be set such that the clk_if capture edge is at the middle point between pdm_clk_out edges. Under ideal conditions the middle point is 1/4 of the PDM interface period for the first/even/left channel, and 3/4 of the PDM interface period for the second/odd/right channel, which corresponds to the following programmings:

SAMPLE_DELAY(left)=((CLOCK_DIV+1)/4) - 1
SAMPLE_DELAY(right)=(3*(CLOCK_DIV+1)/4) - 1

In practice, due to the roundtrip delay, SAMPLE_DELAY may be set to a later point with respect to the ideal middle point. 

Note: in all cases a SAMPLE_DELAY value that brings the capture edge close to the pdm_clk_out edges should be avoided.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CIC_CTL</name>
            <description>CIC control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>DECIM_CODE</name>
                <description>CIC filter decimation. The CIC filter PCM frequency is a fraction of the PDM frequency:
'0': CIC filter PCM frequency is 1/2 * PDM frequency. CIC PCM values are in the range [-0x10, 0x10].
'1': CIC filter PCM frequency is 1/4 * PDM frequency. CIC PCM values are in the range [-0x200, 0x200].
'2': CIC filter PCM frequency is 1/8 * PDM frequency. CIC PCM values are in the range [-0x4000, 0x4000].
'3': CIC filter PCM frequency is 1/16 * PDM frequency. CIC PCM values are in the range [-0x8:0000, 0x8:0000].
'4': CIC filter PCM frequency is 1/32 * PDM frequency. CIC PCM values are in the range [-0x100:0000, 0x100:0000].
'5'-'7': Illegal values.

Note: The CIC filter functionality includes offsetting logic to ensure that 'digital silence' on the PDM interface (an alternating pattern of '0', '1', '0', '1' ... PDM  values) results in CIC filter PCM values of '0'. Similarly, a pattern of '0', '0', '0', ... PDM values results in minimum CIC PCM value (-0x100:0000 when DECIMATION is '4') and a pattern of '1', '1', '1', ... PDM values results in maximum CIC PCM value (0x100:0000 when DECIMATION is '4').

Note: The IP's desired 'clk_sys' frequency is a function of the PDM interface clock, the CIC filter decimation (CIC_CTL.DECIM_CODE[]) and the FIR filter decimation (FIR_CTL.DECIM_CODE[]).</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_8</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_16</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_32</name>
                    <description>This is the default value and the most realistic value (together with the value '3'). Typically, an overall decimation (or oversample rate (OSR)) of 64 is used, and this is achieved with the default CIC and FIR decimation values.</description>
                    <value>4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FIR0_CTL</name>
            <description>FIR 0 control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80001F07</resetMask>
            <fields>
              <field>
                <name>DECIM3</name>
                <description>FIR filter decimation. The FIR filter PCM frequency is a fraction of the CIC filter PCM frequency:
'0': FIR 0 filter PCM frequency is 1 * CIC filter PCM frequency. The FIR 0 filter is performed for every CIC filter PCM sample.
'1': FIR 0 filter PCM frequency is 1/2 * CIC filter PCM frequency. The FIR 0 filter is performed for every second CIC filter PCM sample.
'2': FIR 0 filter PCM frequency is 1/3 * CIC filter PCM frequency. The FIR 0 filter is performed for every third CIC filter PCM sample.
'3': FIR 0 filter PCM frequency is 1/4 * CIC filter PCM frequency. The FIR 0 filter is performed for every fourth CIC filter PCM sample.
'4': FIR 0 filter PCM frequency is 1/5 * CIC filter PCM frequency. The FIR 0 filter is performed for every fifth CIC filter PCM sample.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_5</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCALE</name>
                <description>FIR 0 filter PCM scaling. FIR 0 filter PCM values (fir0_pcm[44:0]) are scaled (right shifted, rounded and clipped) to 26-bit signed PCM values (fir0_scaled_pcm[25:0]). These 26-bit PCM values are input to the FIR 1 filter. SCALE specifies the right shift amount (and performs a rounding):
'0': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:0]).
'1': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:1] + fir0_pcm[0]).
...
'31': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:31] + fir0_pcm[30]).

With CLIP26(a) defined as:
   if      (a &gt;= 0x1ff:ffff) result =  0x1ff:ffff;
   else if (a &lt; -0x200:0000) result = -0x200:0000;
   else                      result = a;

Note: Clipping is not necessary for larger SCALE values, as the scaled value is guarneteed to be within the 26-bit signed integer range.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SCALE_0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_31</name>
                    <description>N/A</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>FIR 0 filter coefficient enable (does NOT effect FIR filter scaling and FIR filter decimation):
'0': Disabled. The middle FIR filter coefficient (16th coefficient, or tap 15 in [0:29] range) is '1' and all other FIR filter coefficients are '0'; i.e. the FIR filter is a pass through filter and the filter gain is '1'.
   fir0_pcm[44:0] = cic_pcm[25:0] (with sign extension)
'1': Enabled.

Note: This filter is disabled by default, and typically only used for sample frequencies (Fs) of 8 and 16 kHz.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIR1_CTL</name>
            <description>FIR 1 control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000F01</resetValue>
            <resetMask>0x80001F03</resetMask>
            <fields>
              <field>
                <name>DECIM2</name>
                <description>FIR 1 filter decimation. The FIR filter PCM frequency is a fraction of the CIC filter PCM frequency:
'0': FIR 1 filter PCM frequency is 1 * FIR 0 filter PCM frequency. The FIR filter is performed for every FIR 0 filter PCM sample.
'1': FIR 1 filter PCM frequency is 1/2 * FIR 0 filter PCM frequency. The FIR filter is performed for every second FIR 0 filter PCM sample.
'2': FIR 1 filter PCM frequency is 1/3 * FIR 0 filter PCM frequency. The FIR filter is performed for every third FIR 0 filter PCM sample.
'3': FIR 1 filter PCM frequency is 1/4 * FIR 0 filter PCM frequency. The FIR filter is performed for every fourth FIR 0 filter PCM sample.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCALE</name>
                <description>FIR 1 filter PCM scaling. FIR filter PCM values (fir1_pcm[43:0]) are scaled (right shifted, rounded and clipped) to 24-bit signed PCM values (fir1_scaled_pcm[23:0]). These 24-bit PCM values are input to the DC blocker. SCALE specifies the right shift amount (and performs a rounding):
'0': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:0]).
'1': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:1] + fir1_pcm[0]).
...
'31': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:31] + fir1_pcm[30]).

With CLIP24(a) defined as:
   if      (a &gt;= 0x7f:ffff) result =  0x7f:ffff;
   else if (a &lt; -0x80:0000) result = -0x80:0000;
   else                     result = a;

Note: Clipping is not necessary for larger SCALE values, as the scaled value is guarneteed to be within the 24-bit signed integer range.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SCALE_0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_31</name>
                    <description>N/A</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>FIR 1 filter coefficient enable (does NOT effect FIR filter scaling and FIR filter decimation):
'0': Disabled. The middle FIR filter coefficient (28th coefficient, or tap 27 in [0:54] range) is '1' and all other FIR filter coefficients are '0'; i.e. the FIR filter is a pass through filter and the filter gain is '1'.
   fir1_pcm[43:0] = fir0_scaled_pcm[25:0] (with sign extension)
'1': Enabled.

Note: Disabling of the filter functionality is provided for debug purposes.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DC_BLOCK_CTL</name>
            <description>DC block control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000007</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>DC blocker coefficient. The DC blocker is defined as:

dc_block_state_scaled(n-1) = 
       dc_block_state(n-1) 
     - (dc_block_state(n-1) &gt;&gt; (12-CODE))
dc_block_state(n)          = CLIP37 (
       2^13 * (fir1_scaled_pcm(n) - fir1_scaled_pcm(n-1))
     + dc_block_state_scaled(n-1))
dc_block_pcm(n)            = dc_block_state(n) &gt;&gt; 13

This first step is a scaling step of the DC block state. It effectively multiplies the DC block state with a variable 'alpha' that is close to '1': 
'0': alpha = 1 - (1/2^(12-0)) = 0.999755859.
'1': alpha = 1 - (1/2^(12-1)) = 0.999511719.
'2': alpha = 1 - (1/2^(12-2)) = 0.999023438.
'3': alpha = 1 - (1/2^(12-3)) = 0.998046875.
'4': alpha = 1 - (1/2^(12-4)) = 0.99609375.
'5': alpha = 1 - (1/2^(12-5)) = 0.9921875.
'6': alpha = 1 - (1/2^(12-6)) = 0.984375.
'7': alpha = 1 - (1/2^(12-7)) = 0.96875.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CODE_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_4</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_8</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_16</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_32</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_64</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_128</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>DC blocker enable:
'0': Disabled. The functionality is defined as:
dc_block_pcm(n) = fir1_scaled_pcm(n)
'1': Enabled. The functionality is as specified by the CODE field.

Note: disabling of the DC blocker filter functionality is provided for debug purposes.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_CTL</name>
            <description>RX FIFO control</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2003F</resetMask>
            <fields>
              <field>
                <name>TRIGGER_LEVEL</name>
                <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated:
- INTR_RX.FIFO_TRIGGER = (# FIFO entries &gt; TRIGGER_LEVEL)</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EMPTY</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USED_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USED_63</name>
                    <description>N/A</description>
                    <value>63</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FREEZE</name>
                <description>Freeze functionality:
'0': HW writes to the RX FIFO and advances the FIFO write pointer.
'1': HW writes from the RX FIFO have no effect: freeze will not advance the FIFO write pointer.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_STATUS</name>
            <description>RX FIFO status</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F3F007F</resetMask>
            <fields>
              <field>
                <name>USED</name>
                <description>Number of used/occupied entries in the RX FIFO. The field value is in the range [0, 64]. When '0', the FIFO is empty. When '64', the FIFO is full.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_PTR</name>
                <description>RX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_PTR</name>
                <description>RX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[29:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD</name>
            <description>RX FIFO read</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data (PCM sample) read from the RX FIFO. Reading removes the data from the RX FIFO; i.e. behavior is similar to that of a POP operation (RX_FIFO_STATUS.RD_PTR is incremented and RX_FIFO_STATUS.USED is decremented). The read data (DATA) is right aligned (unused bit positions follow the specified sign extension per CTL.WORD_SIGN_EXTEND) when it is read from the FIFO entry (data[23:0]):
- 8 bit, DATA[7:0] = data[23:16].
- 10 bit, DATA[9:0] = data[23:14].
- 12 bit, DATA[11:0] = data[23:12].
- 14 bit, DATA[13:0] = data[23:10].
- 16 bit, DATA[15:0] = data[23:8].
- 18 bit, DATA[17:0] = data[23:6].
- 20 bit, DATA[19:0] = data[23:4].
- 24 bit, DATA[23:0] = data[23:0].
- 32 bit, DATA[31:0] = data[23:0] &lt;&lt; 8.

Note: Reading from an empty RX FIFO activates INTR_RX.FIFO_UNDERFLOW.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD_SILENT</name>
            <description>RX FIFO silent read</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data (PCM sample) read from the RX FIFO. Reading will NOT remove the data  from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. See RX_FIFO_RD for data alignment.

Note: Reading from an empty RX FIFO activates INTR.RX_FIFO_UNDERFLOW (the read returns 0xffff:ffff).

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>HW sets this field to '1', when a RX trigger is generated.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>HW sets this field to '1', when writing to a full RX FIFO (RX_FIFO_STATUS.USED is '64').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>HW sets this field to '1', when reading from an empty RX FIFO (RX_FIFO_STATUS.USED is '0').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>HW sets this field to '1', when CIC filter PCM samples are produced at a faster rate than the FIR filter can process them. This is an indication that the IP system frequency is too low.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>HW sets this field to '1', when PDM samples are generated too fast by the interface logic (interface overflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface overflow is a non-recoverable error and requires SW disabling (CTL.ENABLED) of the receiver clearing INTR_RX.IF_OVERFLOW to '0' does not resolve the interface underflow).

Note: This functionality is intended for debug purposes.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXKEYSCAN</name>
      <description>0</description>
      <baseAddress>0x40920000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>KEYSCAN_CTL</name>
          <description>Keyscan Control Reg</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x79FCC</resetValue>
          <resetMask>0x7FFDD</resetMask>
          <fields>
            <field>
              <name>KS_EN</name>
              <description>Enable the key scan module for keyboard function; specifically, the desired clock to the keyscan module is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GHOST_EN</name>
              <description>Enable ghost detection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KS_INT_EN</name>
              <description>This bit enables the keyscan block to wake the MCU module if key is detected.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KYS_RST_EN</name>
              <description>Enable the reset of the debounce counters with kys_reported_clr bit; the reset clears the following registers: read/write counters for the event FIFO, debounce buffers, debouce counters, debouce up/down registers, cycle tracking registers and the keyscan read counter. For reset to take effect, the following two bits have to be set during clock unfreeze: this kys_rst_en and the 'reported_clear_kys' bit (note: ks_en can be at either states).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_EXT</name>
              <description>Programmable idle duration between column scans.  For example, rc_ext[1:0] = 1 will provide 1 clock cycle idle time of no column scan. This is to alleviate the problem of slow RC delay on some of the keyboard design. The valid values for rc_ext are 1, 2, and 3 (default)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCTC_ROW</name>
              <description>set the number of rows of the key matrx; program to one less than the number of row in the keyboard.(default 7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCTC_COLUMN</name>
              <description>set the number of columns of the key matrx; program to one less than the number of column in the keyboard (default 19)</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PULL_HIGH</name>
              <description>used to pull the columns high after each column scan to alleviate slow rise-time due to a large key matrix capacitance;default is on.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KSI_DRV_HIGH</name>
              <description>(THIS IS NOT USED and implemented in RTL) when in keyboard application this bit enables KSI rows to be outputs and driven high to accelerate the pull-up resistor effect for avoiding false key detection due to otherwise slow rising node</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KYSCLK_STAYON</name>
              <description>the keyscan clock will stay on when set; otherwise, the clock will be gated off by when no activity is detected</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBOUNCE</name>
          <description>Debounce (micro/macro)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x333</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>MD_DEBOUNCE</name>
              <description>macro down debounce count</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MU_DEBOUNCE</name>
              <description>macro up debounce count</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>U_DEBOUNCE</name>
              <description>set the micro debounce count</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYFIFO_CNT</name>
          <description>Number of entries in Key FIFO</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>KEYFIFO_CNT</name>
              <description>This register indicates the number of event that is ready for firmware access in the keycode event FIFO. Firmware to read this register before accessing the keycode event FIFO register. For example, a 1 on this register indicates that there is one event in the keycode event FIFO, so firmware can issue a read to the keycode event FIFO once. This number of key event is the accumulative key event count that is latched at the end of each hardware scan frame in a buffer register, it is then transferred to this event register when the 'freeze' is issued; its value is cleared when 'reported_clear_kys' bit is set in the mia_ctl_adr register. 
Note:
Overflow condition (more than 20 keys detected in the scan cycle) may occur before the whole frame is scanned. If the 'overflow' bit is set and the keyfifo_cnt_adr register contains value that is less than 20, firmware needs to read this register a 2nd time. The balance of the event count will be automatically loaded into this register when the firmware issued 'reported_clear_kys' and 'unfreeze' if the hardware scan frame where overflow occurred has completed. However, perform a kys_rst_en maybe a better</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYFIFO</name>
          <description>KEYFIFO values</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>KEYFIFO</name>
              <description>contains detected key index; the event FIFO is 20-byte deep. After power up reset or soft reset defined by the 'kys_rst_en' bit, the event FIFO will contain 0xFF values.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRACK_SCAN_CYCLE</name>
              <description>a 1 or 0 value that indicates the hardware scan cycle that the key was detected; any key detected in the same hardware scan cycle will have the same track_cycle value. It toggles between 0 &amp; 1 whenever a key in a scan cycle is detected; in other words, this value doesn't change when there is no key detected in the current scan cycle</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEY_UP_DOWN</name>
              <description>indicator of key up (1) or down (0) for each key entry in the FIFO. Each of these bits are associated with the key code at bit[7:0].</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIA_CTL</name>
          <description>MIA CTL (legacy)</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FREEZE_MIA</name>
              <description>This bit when set will latch the accumulated key event count for firmware to access via the keyfifo_cnt_adr. After setting the freeze' bit, firmware needs to poll the 'clkrc_freezed' bit (synchronized to the 24MHz clock in hardware) in the 'mia_status_adr' register until it goes high, at which time read access to keyfifo_cnt &amp; keyfifo_adr can proceed. After read access, firmware need to set this bit to low. The typical latency for freeze is 2.5 cycle of the 128KHz clock ~ 19.5us. Note: the clock in the keyscan module is not stopped when the freeze bit is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REPORTED_CLEAR_KYS</name>
              <description>After reading the MIA registers, firmware set this bit to instruct the MIA keyscan module to clear the keycode status, ghost status, &amp; other internal registers. It is important that firmware clears and sets the bit properly (Read/write by uP). It is important to note that this bit only takes effect when the unfreeze occurs - it is a logical AND between this bit and the unfreeze that clears the registers. Therefore, it is advise that the firmware enters into any 'freeze operation' with the 'reported_clear_kys' bit cleared. (read/writable by uP, read only by MIA)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_LF_SEL</name>
              <description>There is a potential bug when CLK_LF_SEL=1, based on the internals of the mxtk_clk_dividere used, and the output of the divider could be stuck.  Please don't change this register unless there is a desperate need to debug the CLK_MF and switch over to only CLK_LF. ORIGINAL desicription: [Run the mxkeyscan internal processor at 32.786kHz, which will only work for small keypad sizes, and is an extreme way to lower power.  Default is to use the 2MHz clk_mf source from the IMO]</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIA_STATUS</name>
          <description>MIA STAUS (Legacy)</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6F</resetMask>
          <fields>
            <field>
              <name>MIA_CLOCK_FREEZED_STATUS</name>
              <description>Firmware needs to poll this bit when trying to access/read the MIA registers. When this bit is high, the 'freeze' (bit 1 of the ksctl_adr register) is successful. Read access may proceed, otherwise, firmware has to wait and poll this bit until it is high. This bit is write by MIA and readable by the uP.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEYCODE_SET_STATUS</name>
              <description>(Note: these bits can be read anytime, no need to freeze the MIA clock)

keycode_set indiates that the there is event in the key event FIFO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_STATUS</name>
              <description>(Note: these bits can be read anytime, no need to freeze the MIA clock)
key FIFO overflow: The 20-byte key event FIFO overflows; more than 16 keys are pressed during current scan interval.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHOST_STATUS</name>
              <description>(Note: these bits can be read anytime, no need to freeze the MIA clock)
Ghost: indicates the ghost keys are detected; 0xF5 is inserted in the event FIFO. Refer to keyscan_ctl_adr for ghost enable bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KYS_INT_SYNC_STATUS</name>
              <description>(Note: these bits can be read anytime, no need to freeze the MIA clock)

kys_int_sync: status indicating that the keyscan interrupt is set. Refer to keyscan_ctl_adr for keyscan interruptenable - ks_int_en.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_G_TO_KYS_DBG</name>
              <description>Debug status bit, poll this to see if the clock toggles and the divider is working.  Double synced to clk_sys domain as an observe point also should help dft</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KSI_USED</name>
          <description>Number of input key rows</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>KSI_USED</name>
              <description>define the number of row used for Keyscan; this definition is the same as that of the rctc register defined in MIA keyscan_ctl_adr[10:8]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_EDGE</name>
              <description>HW sets this field to '1', when a INTERRUPT_KEY_EDGE trigger is generated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_THRESH</name>
              <description>HW sets this field to '1', when a INTERRUPT_FIFO_THRESH trigger is generated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_EDGE</name>
              <description>Write this field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_THRESH</name>
              <description>Write this field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_EDGE</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_THRESH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt mask</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_EDGE</name>
              <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_THRESH</name>
              <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTSS</name>
      <description>MXS40BLE52SS IP</description>
      <baseAddress>0x42000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16777216</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>DATA_RAM_IPC</name>
          <description>N/A</description>
          <addressOffset>0x00600000</addressOffset>
          <register>
            <name>MXIPC_0_ACQUIRE</name>
            <description>N/A</description>
            <addressOffset>0x80000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_ACQUIRE_P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_ACQUIRE_NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_ACQUIRE_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_ACQUIRE_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_ACQUIRE_SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_0_RELEASE</name>
            <description>N/A</description>
            <addressOffset>0x80004</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_0_NOTIFY</name>
            <description>N/A</description>
            <addressOffset>0x80008</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_0_DATA0</name>
            <description>N/A</description>
            <addressOffset>0x8000C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_DATA0</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_0_DATA1</name>
            <description>N/A</description>
            <addressOffset>0x80010</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_DATA1</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_0_LOCK_STATUS</name>
            <description>N/A</description>
            <addressOffset>0x8001C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_0_LOCK_STATUS_P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_LOCK_STATUS_NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_LOCK_STATUS_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_LOCK_STATUS_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_0_LOCK_STATUS_ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_ACQUIRE</name>
            <description>N/A</description>
            <addressOffset>0x80020</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_ACQUIRE_P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_ACQUIRE_NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_ACQUIRE_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_ACQUIRE_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_ACQUIRE_SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_RELEASE</name>
            <description>N/A</description>
            <addressOffset>0x80024</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_NOTIFY</name>
            <description>N/A</description>
            <addressOffset>0x80028</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_DATA0</name>
            <description>N/A</description>
            <addressOffset>0x8002C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_DATA0</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_DATA1</name>
            <description>N/A</description>
            <addressOffset>0x80030</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_DATA1</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_1_LOCK_STATUS</name>
            <description>N/A</description>
            <addressOffset>0x8003C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_1_LOCK_STATUS_P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_LOCK_STATUS_NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_LOCK_STATUS_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_LOCK_STATUS_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_1_LOCK_STATUS_ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_ACQUIRE</name>
            <description>N/A</description>
            <addressOffset>0x80040</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_ACQUIRE_P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_ACQUIRE_NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_ACQUIRE_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_ACQUIRE_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_ACQUIRE_SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_RELEASE</name>
            <description>N/A</description>
            <addressOffset>0x80044</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_NOTIFY</name>
            <description>N/A</description>
            <addressOffset>0x80048</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_DATA0</name>
            <description>N/A</description>
            <addressOffset>0x8004C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_DATA0</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_DATA1</name>
            <description>N/A</description>
            <addressOffset>0x80050</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_DATA1</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_2_LOCK_STATUS</name>
            <description>N/A</description>
            <addressOffset>0x8005C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_2_LOCK_STATUS_P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_LOCK_STATUS_NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_LOCK_STATUS_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_LOCK_STATUS_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_2_LOCK_STATUS_ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_ACQUIRE</name>
            <description>N/A</description>
            <addressOffset>0x80060</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_ACQUIRE_P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_ACQUIRE_NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_ACQUIRE_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_ACQUIRE_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_ACQUIRE_SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_RELEASE</name>
            <description>N/A</description>
            <addressOffset>0x80064</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_NOTIFY</name>
            <description>N/A</description>
            <addressOffset>0x80068</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_DATA0</name>
            <description>N/A</description>
            <addressOffset>0x8006C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_DATA0</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_DATA1</name>
            <description>N/A</description>
            <addressOffset>0x80070</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_DATA1</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_3_LOCK_STATUS</name>
            <description>N/A</description>
            <addressOffset>0x8007C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>MXIPC_3_LOCK_STATUS_P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_LOCK_STATUS_NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_LOCK_STATUS_PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_LOCK_STATUS_MS</name>
                <description>This field specifies the bus master identifier ({HMASTER[MASTER_WIDTH-2:0], HMASTER[MASTER_WIDTH}) that successfully acquired the lock. (MASTER_WIDTH = 4)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_3_LOCK_STATUS_ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_0</name>
            <description>N/A</description>
            <addressOffset>0x81000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_0_MXIPC_INTR_0_RELEASE_______</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_0_MXIPC_INTR_0_NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_0_SET</name>
            <description>N/A</description>
            <addressOffset>0x81004</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_0_SET_MXIPC_INTR_0_SET_RELEASE_______</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_0_SET_MXIPC_INTR_0_SET_NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_0_MASK</name>
            <description>N/A</description>
            <addressOffset>0x81008</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_0_MASK_MXIPC_INTR_0_MASK_RELEASE_______</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_0_MASK_MXIPC_INTR_0_MASK_NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_0_MASKED</name>
            <description>N/A</description>
            <addressOffset>0x8100C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_0_MASKED_MXIPC_INTR_0_MASKED_RELEASE_______</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_INTR_0_MASKED_MXIPC_INTR_0_MASKED_NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_1</name>
            <description>N/A</description>
            <addressOffset>0x81020</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_1_MXIPC_INTR_1_RELEASE_______</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_1_MXIPC_INTR_1_NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_1_SET</name>
            <description>N/A</description>
            <addressOffset>0x81024</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_1_SET_MXIPC_INTR_1_SET_RELEASE_______</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_1_SET_MXIPC_INTR_1_SET_NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_1_MASK</name>
            <description>N/A</description>
            <addressOffset>0x81028</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_1_MASK_MXIPC_INTR_1_MASK_RELEASE_______</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MXIPC_INTR_1_MASK_MXIPC_INTR_1_MASK_NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MXIPC_INTR_1_MASKED</name>
            <description>N/A</description>
            <addressOffset>0x8102C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MXIPC_INTR_1_MASKED_MXIPC_INTR_1_MASKED_RELEASE_______</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MXIPC_INTR_1_MASKED_MXIPC_INTR_1_MASKED_NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
  </peripherals>
</device>